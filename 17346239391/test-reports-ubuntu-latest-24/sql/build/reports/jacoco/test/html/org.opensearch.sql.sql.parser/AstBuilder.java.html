<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AstBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sql</a> &gt; <a href="index.source.html" class="el_package">org.opensearch.sql.sql.parser</a> &gt; <span class="el_source">AstBuilder.java</span></div><h1>AstBuilder.java</h1><pre class="source lang-java linenums">/*
 * Copyright OpenSearch Contributors
 * SPDX-License-Identifier: Apache-2.0
 */

package org.opensearch.sql.sql.parser;

import static java.util.Collections.emptyList;
import static org.opensearch.sql.ast.dsl.AstDSL.qualifiedName;
import static org.opensearch.sql.sql.antlr.parser.OpenSearchSQLParser.FromClauseContext;
import static org.opensearch.sql.sql.antlr.parser.OpenSearchSQLParser.HavingClauseContext;
import static org.opensearch.sql.sql.antlr.parser.OpenSearchSQLParser.SelectClauseContext;
import static org.opensearch.sql.sql.antlr.parser.OpenSearchSQLParser.SelectElementContext;
import static org.opensearch.sql.sql.antlr.parser.OpenSearchSQLParser.SubqueryAsRelationContext;
import static org.opensearch.sql.sql.antlr.parser.OpenSearchSQLParser.TableAsRelationContext;
import static org.opensearch.sql.sql.antlr.parser.OpenSearchSQLParser.WhereClauseContext;
import static org.opensearch.sql.sql.parser.ParserUtils.getTextInQuery;
import static org.opensearch.sql.utils.SystemIndexUtils.TABLE_INFO;
import static org.opensearch.sql.utils.SystemIndexUtils.mappingTable;

import com.google.common.collect.ImmutableList;
import java.util.Collections;
import java.util.Optional;
import lombok.RequiredArgsConstructor;
import org.antlr.v4.runtime.tree.ParseTree;
import org.opensearch.sql.ast.expression.Alias;
import org.opensearch.sql.ast.expression.AllFields;
import org.opensearch.sql.ast.expression.Function;
import org.opensearch.sql.ast.expression.UnresolvedExpression;
import org.opensearch.sql.ast.tree.DescribeRelation;
import org.opensearch.sql.ast.tree.Filter;
import org.opensearch.sql.ast.tree.Limit;
import org.opensearch.sql.ast.tree.Project;
import org.opensearch.sql.ast.tree.Relation;
import org.opensearch.sql.ast.tree.RelationSubquery;
import org.opensearch.sql.ast.tree.SubqueryAlias;
import org.opensearch.sql.ast.tree.UnresolvedPlan;
import org.opensearch.sql.ast.tree.Values;
import org.opensearch.sql.common.antlr.SyntaxCheckException;
import org.opensearch.sql.common.utils.StringUtils;
import org.opensearch.sql.expression.function.BuiltinFunctionName;
import org.opensearch.sql.sql.antlr.parser.OpenSearchSQLParser;
import org.opensearch.sql.sql.antlr.parser.OpenSearchSQLParser.QuerySpecificationContext;
import org.opensearch.sql.sql.antlr.parser.OpenSearchSQLParserBaseVisitor;
import org.opensearch.sql.sql.parser.context.ParsingContext;

/** Abstract syntax tree (AST) builder. */
@RequiredArgsConstructor
public class AstBuilder extends OpenSearchSQLParserBaseVisitor&lt;UnresolvedPlan&gt; {

  private final AstExpressionBuilder expressionBuilder = new AstExpressionBuilder();

  /** Parsing context stack that contains context for current query parsing. */
  private final ParsingContext context = new ParsingContext();

  /**
   * SQL query to get original token text. This is necessary because token.getText() returns text
   * without whitespaces or other characters discarded by lexer.
   */
  private final String query;

  @Override
  public UnresolvedPlan visitShowStatement(OpenSearchSQLParser.ShowStatementContext ctx) {
<span class="fc" id="L64">    final UnresolvedExpression tableFilter = visitAstExpression(ctx.tableFilter());</span>
<span class="fc" id="L65">    return new Project(Collections.singletonList(AllFields.of()))</span>
<span class="fc" id="L66">        .attach(new Filter(tableFilter).attach(new DescribeRelation(qualifiedName(TABLE_INFO))));</span>
  }

  @Override
  public UnresolvedPlan visitDescribeStatement(OpenSearchSQLParser.DescribeStatementContext ctx) {
<span class="fc" id="L71">    final Function tableFilter = (Function) visitAstExpression(ctx.tableFilter());</span>
<span class="fc" id="L72">    final String tableName = tableFilter.getFuncArgs().get(1).toString();</span>
<span class="fc" id="L73">    final Relation table = new DescribeRelation(qualifiedName(mappingTable(tableName.toString())));</span>
<span class="fc bfc" id="L74" title="All 2 branches covered.">    if (ctx.columnFilter() == null) {</span>
<span class="fc" id="L75">      return new Project(Collections.singletonList(AllFields.of())).attach(table);</span>
    } else {
<span class="fc" id="L77">      return new Project(Collections.singletonList(AllFields.of()))</span>
<span class="fc" id="L78">          .attach(new Filter(visitAstExpression(ctx.columnFilter())).attach(table));</span>
    }
  }

  @Override
  public UnresolvedPlan visitQuerySpecification(QuerySpecificationContext queryContext) {
<span class="fc" id="L84">    context.push();</span>
<span class="fc" id="L85">    context.peek().collect(queryContext, query);</span>

<span class="fc" id="L87">    Project project = (Project) visit(queryContext.selectClause());</span>

<span class="fc bfc" id="L89" title="All 2 branches covered.">    if (queryContext.fromClause() == null) {</span>
<span class="fc" id="L90">      Optional&lt;UnresolvedExpression&gt; allFields =</span>
<span class="fc" id="L91">          project.getProjectList().stream().filter(node -&gt; node instanceof AllFields).findFirst();</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">      if (allFields.isPresent()) {</span>
<span class="fc" id="L93">        throw new SyntaxCheckException(&quot;No FROM clause found for select all&quot;);</span>
      }
      // Attach an Values operator with only a empty row inside so that
      // Project operator can have a chance to evaluate its expression
      // though the evaluation doesn't have any dependency on what's in Values.
<span class="fc" id="L98">      Values emptyValue = new Values(ImmutableList.of(emptyList()));</span>
<span class="fc" id="L99">      return project.attach(emptyValue);</span>
    }

    // If limit (and offset) keyword exists:
    // Add Limit node, plan structure becomes:
    // Project -&gt; Limit -&gt; visit(fromClause)
    // Else:
    // Project -&gt; visit(fromClause)
<span class="fc" id="L107">    UnresolvedPlan from = visit(queryContext.fromClause());</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">    if (queryContext.limitClause() != null) {</span>
<span class="fc" id="L109">      from = visit(queryContext.limitClause()).attach(from);</span>
    }
<span class="fc" id="L111">    UnresolvedPlan result = project.attach(from);</span>
<span class="fc" id="L112">    context.pop();</span>
<span class="fc" id="L113">    return result;</span>
  }

  @Override
  public UnresolvedPlan visitSelectClause(SelectClauseContext ctx) {
<span class="fc" id="L118">    ImmutableList.Builder&lt;UnresolvedExpression&gt; builder = new ImmutableList.Builder&lt;&gt;();</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">    if (ctx.selectElements().star != null) { // TODO: project operator should be required?</span>
<span class="fc" id="L120">      builder.add(AllFields.of());</span>
    }
<span class="fc" id="L122">    ctx.selectElements().selectElement().forEach(field -&gt; builder.add(visitSelectItem(field)));</span>
<span class="fc" id="L123">    return new Project(builder.build());</span>
  }

  @Override
  public UnresolvedPlan visitLimitClause(OpenSearchSQLParser.LimitClauseContext ctx) {
<span class="fc" id="L128">    return new Limit(</span>
<span class="fc" id="L129">        Integer.parseInt(ctx.limit.getText()),</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">        ctx.offset == null ? 0 : Integer.parseInt(ctx.offset.getText()));</span>
  }

  @Override
  public UnresolvedPlan visitFromClause(FromClauseContext ctx) {
<span class="fc" id="L135">    UnresolvedPlan result = visit(ctx.relation());</span>

<span class="fc bfc" id="L137" title="All 2 branches covered.">    if (ctx.whereClause() != null) {</span>
<span class="fc" id="L138">      result = visit(ctx.whereClause()).attach(result);</span>
    }

    // Because aggregation maybe implicit, this has to be handled here instead of visitGroupByClause
<span class="fc" id="L142">    AstAggregationBuilder aggBuilder = new AstAggregationBuilder(context.peek());</span>
<span class="fc" id="L143">    UnresolvedPlan aggregation = aggBuilder.visit(ctx.groupByClause());</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">    if (aggregation != null) {</span>
<span class="fc" id="L145">      result = aggregation.attach(result);</span>
    }

<span class="fc bfc" id="L148" title="All 2 branches covered.">    if (ctx.havingClause() != null) {</span>
<span class="fc" id="L149">      UnresolvedPlan havingPlan = visit(ctx.havingClause());</span>
<span class="fc" id="L150">      verifySupportsCondition(((Filter) havingPlan).getCondition());</span>
<span class="fc" id="L151">      result = visit(ctx.havingClause()).attach(result);</span>
    }

<span class="fc bfc" id="L154" title="All 2 branches covered.">    if (ctx.orderByClause() != null) {</span>
<span class="fc" id="L155">      AstSortBuilder sortBuilder = new AstSortBuilder(context.peek());</span>
<span class="fc" id="L156">      result = sortBuilder.visit(ctx.orderByClause()).attach(result);</span>
    }
<span class="fc" id="L158">    return result;</span>
  }

  /**
   * Ensure NESTED function is not used in HAVING clause and fallback to legacy engine. Can remove
   * when support is added for NESTED function in HAVING clause.
   *
   * @param func : Function in HAVING clause
   */
  private void verifySupportsCondition(UnresolvedExpression func) {
<span class="fc bfc" id="L168" title="All 2 branches covered.">    if (func instanceof Function) {</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">      if (((Function) func).getFuncName().equalsIgnoreCase(BuiltinFunctionName.NESTED.name())) {</span>
<span class="fc" id="L170">        throw new SyntaxCheckException(</span>
            &quot;Falling back to legacy engine. Nested function is not supported in the HAVING&quot;
                + &quot; clause.&quot;);
      }
<span class="fc" id="L174">      ((Function) func).getFuncArgs().stream().forEach(e -&gt; verifySupportsCondition(e));</span>
    }
<span class="fc" id="L176">  }</span>

  @Override
  public UnresolvedPlan visitTableAsRelation(TableAsRelationContext ctx) {
<span class="fc" id="L180">    Relation relation = new Relation(visitAstExpression(ctx.tableName()));</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">    return ctx.alias() != null</span>
<span class="fc" id="L182">        ? new SubqueryAlias(StringUtils.unquoteIdentifier(ctx.alias().getText()), relation)</span>
<span class="fc" id="L183">        : relation;</span>
  }

  @Override
  public UnresolvedPlan visitSubqueryAsRelation(SubqueryAsRelationContext ctx) {
<span class="fc" id="L188">    String subqueryAlias = StringUtils.unquoteIdentifier(ctx.alias().getText());</span>
<span class="fc" id="L189">    return new RelationSubquery(visit(ctx.subquery), subqueryAlias);</span>
  }

  @Override
  public UnresolvedPlan visitWhereClause(WhereClauseContext ctx) {
<span class="fc" id="L194">    return new Filter(visitAstExpression(ctx.expression()));</span>
  }

  @Override
  public UnresolvedPlan visitHavingClause(HavingClauseContext ctx) {
<span class="fc" id="L199">    AstHavingFilterBuilder builder = new AstHavingFilterBuilder(context.peek());</span>
<span class="fc" id="L200">    return new Filter(builder.visit(ctx.expression()));</span>
  }

  @Override
  protected UnresolvedPlan aggregateResult(UnresolvedPlan aggregate, UnresolvedPlan nextResult) {
<span class="fc bfc" id="L205" title="All 2 branches covered.">    return nextResult != null ? nextResult : aggregate;</span>
  }

  private UnresolvedExpression visitAstExpression(ParseTree tree) {
<span class="fc" id="L209">    return expressionBuilder.visit(tree);</span>
  }

  private UnresolvedExpression visitSelectItem(SelectElementContext ctx) {
<span class="fc" id="L213">    String name = StringUtils.unquoteIdentifier(getTextInQuery(ctx.expression(), query));</span>
<span class="fc" id="L214">    UnresolvedExpression expr = visitAstExpression(ctx.expression());</span>

<span class="fc bfc" id="L216" title="All 2 branches covered.">    if (ctx.alias() == null) {</span>
<span class="fc" id="L217">      return Alias.newAliasAllowMetaMetaField(name, expr, null);</span>
    } else {
<span class="fc" id="L219">      String alias = StringUtils.unquoteIdentifier(ctx.alias().getText());</span>
<span class="fc" id="L220">      return Alias.newAliasAllowMetaMetaField(name, expr, alias);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>