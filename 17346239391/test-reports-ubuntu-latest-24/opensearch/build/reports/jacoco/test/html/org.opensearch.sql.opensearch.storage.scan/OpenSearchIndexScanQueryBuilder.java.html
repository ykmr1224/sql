<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OpenSearchIndexScanQueryBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">opensearch</a> &gt; <a href="index.source.html" class="el_package">org.opensearch.sql.opensearch.storage.scan</a> &gt; <span class="el_source">OpenSearchIndexScanQueryBuilder.java</span></div><h1>OpenSearchIndexScanQueryBuilder.java</h1><pre class="source lang-java linenums">/*
 * Copyright OpenSearch Contributors
 * SPDX-License-Identifier: Apache-2.0
 */

package org.opensearch.sql.opensearch.storage.scan;

import com.google.common.annotations.VisibleForTesting;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import lombok.EqualsAndHashCode;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.opensearch.index.query.QueryBuilder;
import org.opensearch.sql.ast.tree.Sort;
import org.opensearch.sql.common.utils.StringUtils;
import org.opensearch.sql.expression.Expression;
import org.opensearch.sql.expression.ExpressionNodeVisitor;
import org.opensearch.sql.expression.FunctionExpression;
import org.opensearch.sql.expression.NamedExpression;
import org.opensearch.sql.expression.ReferenceExpression;
import org.opensearch.sql.expression.function.OpenSearchFunctions;
import org.opensearch.sql.opensearch.request.OpenSearchRequestBuilder;
import org.opensearch.sql.opensearch.request.OpenSearchRequestBuilder.PushDownUnSupportedException;
import org.opensearch.sql.opensearch.storage.script.filter.FilterQueryBuilder;
import org.opensearch.sql.opensearch.storage.script.filter.FilterQueryBuilder.ScriptQueryUnSupportedException;
import org.opensearch.sql.opensearch.storage.script.sort.SortQueryBuilder;
import org.opensearch.sql.opensearch.storage.serde.DefaultExpressionSerializer;
import org.opensearch.sql.planner.logical.LogicalFilter;
import org.opensearch.sql.planner.logical.LogicalHighlight;
import org.opensearch.sql.planner.logical.LogicalLimit;
import org.opensearch.sql.planner.logical.LogicalNested;
import org.opensearch.sql.planner.logical.LogicalPaginate;
import org.opensearch.sql.planner.logical.LogicalProject;
import org.opensearch.sql.planner.logical.LogicalSort;

/**
 * Index scan builder for simple non-aggregate query used by {@link OpenSearchIndexScanBuilder}
 * internally.
 */
@VisibleForTesting
@EqualsAndHashCode
class OpenSearchIndexScanQueryBuilder implements PushDownQueryBuilder {
<span class="fc" id="L48">  private static final Logger LOG = LogManager.getLogger(OpenSearchIndexScanQueryBuilder.class);</span>

  final OpenSearchRequestBuilder requestBuilder;

<span class="fc" id="L52">  public OpenSearchIndexScanQueryBuilder(OpenSearchRequestBuilder requestBuilder) {</span>
<span class="fc" id="L53">    this.requestBuilder = requestBuilder;</span>
<span class="fc" id="L54">  }</span>

  @Override
  public boolean pushDownFilter(LogicalFilter filter) {
<span class="fc" id="L58">    FilterQueryBuilder queryBuilder = new FilterQueryBuilder(new DefaultExpressionSerializer());</span>
<span class="fc" id="L59">    Expression queryCondition = filter.getCondition();</span>
    try {
<span class="fc" id="L61">      QueryBuilder query = queryBuilder.build(queryCondition);</span>
<span class="fc" id="L62">      requestBuilder.pushDownFilter(query);</span>
<span class="fc" id="L63">      requestBuilder.pushDownTrackedScore(trackScoresFromOpenSearchFunction(queryCondition));</span>
<span class="fc" id="L64">      return true;</span>
<span class="nc" id="L65">    } catch (ScriptQueryUnSupportedException e) {</span>
      // Don't catch SyntaxCheckException, which should fall back to the old SQL engine.
      // See test {@link NestedIT::test_nested_where_with_and_conditional}, only the old SQL engine
      // can cover this case.
      // It will fail if catching SyntaxCheckException here and keep using v2 engine.
<span class="nc bnc" id="L70" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L71">        LOG.debug(&quot;Cannot pushdown the filter condition.&quot;, e);</span>
      } else {
<span class="nc" id="L73">        LOG.info(&quot;Cannot pushdown the filter condition.&quot;);</span>
      }
<span class="nc" id="L75">      return false;</span>
    }
  }

  @Override
  public boolean pushDownSort(LogicalSort sort) {
<span class="fc" id="L81">    List&lt;Pair&lt;Sort.SortOption, Expression&gt;&gt; sortList = sort.getSortList();</span>
<span class="fc" id="L82">    final SortQueryBuilder builder = new SortQueryBuilder();</span>
<span class="fc" id="L83">    requestBuilder.pushDownSort(</span>
<span class="fc" id="L84">        sortList.stream()</span>
<span class="fc" id="L85">            .map(sortItem -&gt; builder.build(sortItem.getValue(), sortItem.getKey()))</span>
<span class="fc" id="L86">            .collect(Collectors.toList()));</span>
    // Handle count parameter for sort with limit
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">    if (sort.getCount() != 0) {</span>
<span class="nc" id="L89">      requestBuilder.pushDownLimit(sort.getCount(), 0);</span>
    }

<span class="fc" id="L92">    return true;</span>
  }

  @Override
  public boolean pushDownLimit(LogicalLimit limit) {
    try {
<span class="fc" id="L98">      requestBuilder.pushDownLimit(limit.getLimit(), limit.getOffset());</span>
<span class="fc" id="L99">      return true;</span>
<span class="nc" id="L100">    } catch (PushDownUnSupportedException e) {</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">      if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L102">        LOG.debug(</span>
<span class="nc" id="L103">            &quot;Cannot pushdown limit {} with offset {}&quot;, limit.getLimit(), limit.getOffset(), e);</span>
      } else {
<span class="nc" id="L105">        LOG.info(&quot;Cannot pushdown limit {} with offset {}&quot;, limit.getLimit(), limit.getOffset());</span>
      }
<span class="nc" id="L107">      return false;</span>
    }
  }

  @Override
  public boolean pushDownProject(LogicalProject project) {
<span class="fc" id="L113">    requestBuilder.pushDownProjects(findReferenceExpressions(project.getProjectList()));</span>

    // Return false intentionally to keep the original project operator
<span class="fc" id="L116">    return false;</span>
  }

  @Override
  public boolean pushDownHighlight(LogicalHighlight highlight) {
<span class="fc" id="L121">    requestBuilder.pushDownHighlight(</span>
<span class="fc" id="L122">        StringUtils.unquoteText(highlight.getHighlightField().toString()),</span>
<span class="fc" id="L123">        highlight.getArguments());</span>
<span class="fc" id="L124">    return true;</span>
  }

  @Override
  public boolean pushDownPageSize(LogicalPaginate paginate) {
<span class="fc" id="L129">    requestBuilder.pushDownPageSize(paginate.getPageSize());</span>
<span class="fc" id="L130">    return true;</span>
  }

  private boolean trackScoresFromOpenSearchFunction(Expression condition) {
<span class="fc bfc" id="L134" title="All 2 branches covered.">    if (condition instanceof OpenSearchFunctions.OpenSearchFunction</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">        &amp;&amp; ((OpenSearchFunctions.OpenSearchFunction) condition).isScoreTracked()) {</span>
<span class="fc" id="L136">      return true;</span>
    }
<span class="fc bfc" id="L138" title="All 2 branches covered.">    if (condition instanceof FunctionExpression) {</span>
<span class="fc" id="L139">      return ((FunctionExpression) condition)</span>
<span class="fc" id="L140">          .getArguments().stream().anyMatch(this::trackScoresFromOpenSearchFunction);</span>
    }
<span class="fc" id="L142">    return false;</span>
  }

  @Override
  public boolean pushDownNested(LogicalNested nested) {
<span class="fc" id="L147">    requestBuilder.pushDownNested(nested.getFields());</span>
<span class="fc" id="L148">    requestBuilder.pushDownProjects(findReferenceExpressions(nested.getProjectList()));</span>
    // Return false intentionally to keep the original nested operator
    // Since we return false we need to pushDownProject here as it won't be
    // pushed down due to no matching push down rule.
    // TODO: improve LogicalPlanOptimizer pushdown api.
<span class="fc" id="L153">    return false;</span>
  }

  @Override
  public OpenSearchRequestBuilder build() {
<span class="fc" id="L158">    return requestBuilder;</span>
  }

  /**
   * Find reference expression from expression.
   *
   * @param expressions a list of expression.
   * @return a set of ReferenceExpression
   */
  public static Set&lt;ReferenceExpression&gt; findReferenceExpressions(
      List&lt;NamedExpression&gt; expressions) {
    // Use LinkedHashSet to make sure explained OpenSearchRequest included fields in order
<span class="fc" id="L170">    Set&lt;ReferenceExpression&gt; projectList = new LinkedHashSet&lt;&gt;();</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">    for (NamedExpression namedExpression : expressions) {</span>
<span class="fc" id="L172">      projectList.addAll(findReferenceExpression(namedExpression));</span>
<span class="fc" id="L173">    }</span>
<span class="fc" id="L174">    return projectList;</span>
  }

  /**
   * Find reference expression from expression.
   *
   * @param expression expression.
   * @return a list of ReferenceExpression
   */
  public static List&lt;ReferenceExpression&gt; findReferenceExpression(NamedExpression expression) {
<span class="fc" id="L184">    List&lt;ReferenceExpression&gt; results = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L185">    expression.accept(</span>
<span class="fc" id="L186">        new ExpressionNodeVisitor&lt;&gt;() {</span>
          @Override
          public Object visitReference(ReferenceExpression node, Object context) {
<span class="fc" id="L189">            return results.add(node);</span>
          }
        },
        null);
<span class="fc" id="L193">    return results;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>