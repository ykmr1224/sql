<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DateTimeUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">core</a> &gt; <a href="index.source.html" class="el_package">org.opensearch.sql.utils</a> &gt; <span class="el_source">DateTimeUtils.java</span></div><h1>DateTimeUtils.java</h1><pre class="source lang-java linenums">/*
 * Copyright OpenSearch Contributors
 * SPDX-License-Identifier: Apache-2.0
 */

package org.opensearch.sql.utils;

import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.time.temporal.ChronoUnit;
import java.util.Locale;
import java.util.regex.Pattern;
import lombok.experimental.UtilityClass;
import org.opensearch.sql.data.model.ExprTimeValue;
import org.opensearch.sql.data.model.ExprValue;
import org.opensearch.sql.expression.function.FunctionProperties;

@UtilityClass
public class DateTimeUtils {

<span class="fc" id="L27">  private static final Pattern OFFSET_PATTERN = Pattern.compile(&quot;([+-])(\\d+)([smhdwMy]?)&quot;);</span>
<span class="fc" id="L28">  private static final DateTimeFormatter DIRECT_FORMATTER =</span>
<span class="fc" id="L29">      DateTimeFormatter.ofPattern(&quot;MM/dd/yyyy:HH:mm:ss&quot;);</span>

  /**
   * Util method to round the date/time with given unit.
   *
   * @param utcMillis Date/time value to round, given in utc millis
   * @param unitMillis Date/time interval unit in utc millis
   * @return Rounded date/time value in utc millis
   */
  public static long roundFloor(long utcMillis, long unitMillis) {
<span class="fc" id="L39">    long res = utcMillis - utcMillis % unitMillis;</span>
<span class="pc bpc" id="L40" title="1 of 4 branches missed.">    return (utcMillis &lt; 0 &amp;&amp; res != utcMillis) ? res - unitMillis : res;</span>
  }

  /**
   * Util method to round the date/time in week(s).
   *
   * @param utcMillis Date/time value to round, given in utc millis
   * @param interval Number of weeks as the rounding interval
   * @return Rounded date/time value in utc millis
   */
  public static long roundWeek(long utcMillis, int interval) {
<span class="fc" id="L51">    return roundFloor(utcMillis + 259200000L, 604800000L * interval) - 259200000L;</span>
  }

  /**
   * Util method to round the date/time in month(s).
   *
   * @param utcMillis Date/time value to round, given in utc millis
   * @param interval Number of months as the rounding interval
   * @return Rounded date/time value in utc millis
   */
  public static long roundMonth(long utcMillis, int interval) {
<span class="fc" id="L62">    ZonedDateTime initDateTime = ZonedDateTime.of(1970, 1, 1, 0, 0, 0, 0, ZoneOffset.UTC);</span>
<span class="fc" id="L63">    ZonedDateTime zonedDateTime =</span>
<span class="fc" id="L64">        Instant.ofEpochMilli(utcMillis).atZone(ZoneOffset.UTC).plusMonths(interval);</span>
<span class="fc" id="L65">    long monthDiff =</span>
<span class="fc" id="L66">        (zonedDateTime.getYear() - initDateTime.getYear()) * 12L</span>
<span class="fc" id="L67">            + zonedDateTime.getMonthValue()</span>
<span class="fc" id="L68">            - initDateTime.getMonthValue();</span>
<span class="fc" id="L69">    long multiplier = monthDiff / interval - 1;</span>
<span class="pc bpc" id="L70" title="1 of 4 branches missed.">    if (monthDiff &lt; 0 &amp;&amp; monthDiff % interval != 0) --multiplier;</span>
<span class="fc" id="L71">    long monthToAdd = multiplier * interval;</span>
<span class="fc" id="L72">    return initDateTime.plusMonths(monthToAdd).toInstant().toEpochMilli();</span>
  }

  /**
   * Util method to round the date/time in quarter(s).
   *
   * @param utcMillis Date/time value to round, given in utc millis
   * @param interval Number of quarters as the rounding interval
   * @return Rounded date/time value in utc millis
   */
  public static long roundQuarter(long utcMillis, int interval) {
<span class="fc" id="L83">    ZonedDateTime initDateTime = ZonedDateTime.of(1970, 1, 1, 0, 0, 0, 0, ZoneOffset.UTC);</span>
<span class="fc" id="L84">    ZonedDateTime zonedDateTime =</span>
<span class="fc" id="L85">        Instant.ofEpochMilli(utcMillis).atZone(ZoneOffset.UTC).plusMonths(interval * 3L);</span>
<span class="fc" id="L86">    long monthDiff =</span>
<span class="fc" id="L87">        ((zonedDateTime.getYear() - initDateTime.getYear()) * 12L</span>
<span class="fc" id="L88">            + zonedDateTime.getMonthValue()</span>
<span class="fc" id="L89">            - initDateTime.getMonthValue());</span>
<span class="fc" id="L90">    long multiplier = monthDiff / (interval * 3L) - 1;</span>
<span class="pc bpc" id="L91" title="1 of 4 branches missed.">    if (monthDiff &lt; 0 &amp;&amp; monthDiff % (interval * 3L) != 0) --multiplier;</span>
<span class="fc" id="L92">    long monthToAdd = multiplier * interval * 3;</span>
<span class="fc" id="L93">    return initDateTime.plusMonths(monthToAdd).toInstant().toEpochMilli();</span>
  }

  /**
   * Util method to round the date/time in year(s).
   *
   * @param utcMillis Date/time value to round, given in utc millis
   * @param interval Number of years as the rounding interval
   * @return Rounded date/time value in utc millis
   */
  public static long roundYear(long utcMillis, int interval) {
<span class="fc" id="L104">    ZonedDateTime initDateTime = ZonedDateTime.of(1970, 1, 1, 0, 0, 0, 0, ZoneOffset.UTC);</span>
<span class="fc" id="L105">    ZonedDateTime zonedDateTime = Instant.ofEpochMilli(utcMillis).atZone(ZoneOffset.UTC);</span>
<span class="fc" id="L106">    int yearDiff = zonedDateTime.getYear() - initDateTime.getYear();</span>
<span class="fc" id="L107">    int multiplier = yearDiff / interval;</span>
<span class="pc bpc" id="L108" title="1 of 4 branches missed.">    if (yearDiff &lt; 0 &amp;&amp; yearDiff % interval != 0) --multiplier;</span>
<span class="fc" id="L109">    int yearToAdd = multiplier * interval;</span>
<span class="fc" id="L110">    return initDateTime.plusYears(yearToAdd).toInstant().toEpochMilli();</span>
  }

  /**
   * Get window start time which aligns with the given size.
   *
   * @param timestamp event timestamp
   * @param size defines a window's start time to align with
   * @return start timestamp of the window
   */
  public long getWindowStartTime(long timestamp, long size) {
<span class="fc" id="L121">    return timestamp - timestamp % size;</span>
  }

  /**
   * isValidMySqlTimeZoneId for timezones which match timezone the range set by MySQL.
   *
   * @param zone ZoneId of ZoneId type.
   * @return Boolean.
   */
  public Boolean isValidMySqlTimeZoneId(ZoneId zone) {
<span class="fc" id="L131">    String timeZoneMax = &quot;+14:00&quot;;</span>
<span class="fc" id="L132">    String timeZoneMin = &quot;-13:59&quot;;</span>
<span class="fc" id="L133">    String timeZoneZero = &quot;+00:00&quot;;</span>

<span class="fc" id="L135">    ZoneId maxTz = ZoneId.of(timeZoneMax);</span>
<span class="fc" id="L136">    ZoneId minTz = ZoneId.of(timeZoneMin);</span>
<span class="fc" id="L137">    ZoneId defaultTz = ZoneId.of(timeZoneZero);</span>

<span class="fc" id="L139">    ZonedDateTime defaultDateTime = LocalDateTime.of(2000, 1, 2, 12, 0).atZone(defaultTz);</span>

<span class="fc" id="L141">    ZonedDateTime maxTzValidator =</span>
<span class="fc" id="L142">        defaultDateTime.withZoneSameInstant(maxTz).withZoneSameLocal(defaultTz);</span>
<span class="fc" id="L143">    ZonedDateTime minTzValidator =</span>
<span class="fc" id="L144">        defaultDateTime.withZoneSameInstant(minTz).withZoneSameLocal(defaultTz);</span>
<span class="fc" id="L145">    ZonedDateTime passedTzValidator =</span>
<span class="fc" id="L146">        defaultDateTime.withZoneSameInstant(zone).withZoneSameLocal(defaultTz);</span>

<span class="fc bfc" id="L148" title="All 4 branches covered.">    return (passedTzValidator.isBefore(maxTzValidator) || passedTzValidator.isEqual(maxTzValidator))</span>
<span class="fc bfc" id="L149" title="All 4 branches covered.">        &amp;&amp; (passedTzValidator.isAfter(minTzValidator) || passedTzValidator.isEqual(minTzValidator));</span>
  }

  /**
   * Extracts LocalDateTime from a datetime ExprValue. Uses `FunctionProperties` for
   * `ExprTimeValue`.
   */
  public static Instant extractTimestamp(ExprValue value, FunctionProperties functionProperties) {
<span class="fc bfc" id="L157" title="All 2 branches covered.">    return value instanceof ExprTimeValue</span>
<span class="fc" id="L158">        ? ((ExprTimeValue) value).timestampValue(functionProperties)</span>
<span class="fc" id="L159">        : value.timestampValue();</span>
  }

  /**
   * Extracts LocalDate from a datetime ExprValue. Uses `FunctionProperties` for `ExprTimeValue`.
   */
  public static LocalDate extractDate(ExprValue value, FunctionProperties functionProperties) {
<span class="fc bfc" id="L166" title="All 2 branches covered.">    return value instanceof ExprTimeValue</span>
<span class="fc" id="L167">        ? ((ExprTimeValue) value).dateValue(functionProperties)</span>
<span class="fc" id="L168">        : value.dateValue();</span>
  }

  public static ZonedDateTime getRelativeZonedDateTime(String input, ZonedDateTime baseTime) {
    try {
<span class="nc" id="L173">      Instant parsed = LocalDateTime.parse(input, DIRECT_FORMATTER).toInstant(ZoneOffset.UTC);</span>
<span class="nc" id="L174">      return parsed.atZone(baseTime.getZone());</span>
<span class="fc" id="L175">    } catch (DateTimeParseException ignored) {</span>
    }

<span class="fc bfc" id="L178" title="All 4 branches covered.">    if (&quot;now&quot;.equalsIgnoreCase(input) || &quot;now()&quot;.equalsIgnoreCase(input)) {</span>
<span class="fc" id="L179">      return baseTime;</span>
    }

<span class="fc" id="L182">    ZonedDateTime result = baseTime;</span>
<span class="fc" id="L183">    int i = 0;</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">    while (i &lt; input.length()) {</span>
<span class="fc" id="L185">      char c = input.charAt(i);</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">      if (c == '@') {</span>
<span class="fc" id="L187">        int j = i + 1;</span>
<span class="fc bfc" id="L188" title="All 4 branches covered.">        while (j &lt; input.length() &amp;&amp; Character.isLetterOrDigit(input.charAt(j))) {</span>
<span class="fc" id="L189">          j++;</span>
        }
<span class="fc" id="L191">        String rawUnit = input.substring(i + 1, j);</span>
<span class="fc" id="L192">        result = applySnap(result, rawUnit);</span>
<span class="fc" id="L193">        i = j;</span>
<span class="fc bfc" id="L194" title="All 4 branches covered.">      } else if (c == '+' || c == '-') {</span>
<span class="fc" id="L195">        int j = i + 1;</span>
<span class="pc bpc" id="L196" title="1 of 4 branches missed.">        while (j &lt; input.length() &amp;&amp; Character.isDigit(input.charAt(j))) {</span>
<span class="fc" id="L197">          j++;</span>
        }
<span class="fc" id="L199">        String valueStr = input.substring(i + 1, j);</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">        int value = valueStr.isEmpty() ? 1 : Integer.parseInt(valueStr);</span>

<span class="fc" id="L202">        int k = j;</span>
<span class="pc bpc" id="L203" title="1 of 4 branches missed.">        while (k &lt; input.length() &amp;&amp; Character.isLetter(input.charAt(k))) {</span>
<span class="fc" id="L204">          k++;</span>
        }
<span class="fc" id="L206">        String rawUnit = input.substring(j, k);</span>
<span class="fc" id="L207">        result = applyOffset(result, String.valueOf(c), value, rawUnit);</span>
<span class="fc" id="L208">        i = k;</span>
<span class="fc" id="L209">      } else {</span>
<span class="fc" id="L210">        throw new IllegalArgumentException(</span>
            &quot;Unexpected character '&quot; + c + &quot;' at position &quot; + i + &quot; in input: &quot; + input);
      }
<span class="fc" id="L213">    }</span>

<span class="fc" id="L215">    return result;</span>
  }

  private static ZonedDateTime applyOffset(
      ZonedDateTime base, String sign, int value, String rawUnit) {
<span class="fc" id="L220">    String unit = normalizeUnit(rawUnit);</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">    if (&quot;q&quot;.equals(unit)) {</span>
<span class="fc" id="L222">      int months = value * 3;</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">      return sign.equals(&quot;-&quot;) ? base.minusMonths(months) : base.plusMonths(months);</span>
    }

    ChronoUnit chronoUnit =
<span class="pc bpc" id="L227" title="4 of 8 branches missed.">        switch (unit) {</span>
<span class="nc" id="L228">          case &quot;s&quot; -&gt; ChronoUnit.SECONDS;</span>
<span class="fc" id="L229">          case &quot;m&quot; -&gt; ChronoUnit.MINUTES;</span>
<span class="fc" id="L230">          case &quot;h&quot; -&gt; ChronoUnit.HOURS;</span>
<span class="fc" id="L231">          case &quot;d&quot; -&gt; ChronoUnit.DAYS;</span>
<span class="nc" id="L232">          case &quot;w&quot; -&gt; ChronoUnit.WEEKS;</span>
<span class="nc" id="L233">          case &quot;M&quot; -&gt; ChronoUnit.MONTHS;</span>
<span class="fc" id="L234">          case &quot;y&quot; -&gt; ChronoUnit.YEARS;</span>
<span class="pc" id="L235">          default -&gt; throw new IllegalArgumentException(&quot;Unsupported offset unit: &quot; + rawUnit);</span>
        };

<span class="fc bfc" id="L238" title="All 2 branches covered.">    return sign.equals(&quot;-&quot;) ? base.minus(value, chronoUnit) : base.plus(value, chronoUnit);</span>
  }

  private static ZonedDateTime applySnap(ZonedDateTime base, String rawUnit) {
<span class="fc" id="L242">    String unit = normalizeUnit(rawUnit);</span>

<span class="pc bpc" id="L244" title="4 of 9 branches missed.">    return switch (unit) {</span>
<span class="nc" id="L245">      case &quot;s&quot; -&gt; base.truncatedTo(ChronoUnit.SECONDS);</span>
<span class="nc" id="L246">      case &quot;m&quot; -&gt; base.truncatedTo(ChronoUnit.MINUTES);</span>
<span class="fc" id="L247">      case &quot;h&quot; -&gt; base.truncatedTo(ChronoUnit.HOURS);</span>
<span class="fc" id="L248">      case &quot;d&quot; -&gt; base.truncatedTo(ChronoUnit.DAYS);</span>
<span class="nc" id="L249">      case &quot;w&quot; -&gt; base.minusDays((base.getDayOfWeek().getValue() % 7)).truncatedTo(ChronoUnit.DAYS);</span>
<span class="fc" id="L250">      case &quot;M&quot; -&gt; base.withDayOfMonth(1).truncatedTo(ChronoUnit.DAYS);</span>
<span class="nc" id="L251">      case &quot;y&quot; -&gt; base.withDayOfYear(1).truncatedTo(ChronoUnit.DAYS);</span>
      case &quot;q&quot; -&gt; {
<span class="fc" id="L253">        int month = base.getMonthValue();</span>
<span class="fc" id="L254">        int quarterStart = ((month - 1) / 3) * 3 + 1;</span>
<span class="fc" id="L255">        yield base.withMonth(quarterStart).withDayOfMonth(1).truncatedTo(ChronoUnit.DAYS);</span>
      }
      default -&gt; {
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">        if (unit.matches(&quot;w[0-7]&quot;)) {</span>
          int targetDay =
<span class="pc bpc" id="L260" title="2 of 4 branches missed.">              unit.equals(&quot;w0&quot;) || unit.equals(&quot;w7&quot;) ? 7 : Integer.parseInt(unit.substring(1));</span>
<span class="fc" id="L261">          int diff = (base.getDayOfWeek().getValue() - targetDay + 7) % 7;</span>
<span class="fc" id="L262">          yield base.minusDays(diff).truncatedTo(ChronoUnit.DAYS);</span>
        } else {
<span class="nc" id="L264">          throw new IllegalArgumentException(&quot;Unsupported snap unit: &quot; + rawUnit);</span>
        }
      }
    };
  }

  private static String normalizeUnit(String rawUnit) {
    // strict minute (m or M)
<span class="pc bpc" id="L272" title="2 of 9 branches missed.">    switch (rawUnit.toLowerCase(Locale.ROOT)) {</span>
      case &quot;m&quot;, &quot;min&quot;, &quot;mins&quot;, &quot;minute&quot;, &quot;minutes&quot; -&gt; {
<span class="fc" id="L274">        return &quot;m&quot;;</span>
      }
      case &quot;s&quot;, &quot;sec&quot;, &quot;secs&quot;, &quot;second&quot;, &quot;seconds&quot; -&gt; {
<span class="nc" id="L277">        return &quot;s&quot;;</span>
      }
      case &quot;h&quot;, &quot;hr&quot;, &quot;hrs&quot;, &quot;hour&quot;, &quot;hours&quot; -&gt; {
<span class="fc" id="L280">        return &quot;h&quot;;</span>
      }
      case &quot;d&quot;, &quot;day&quot;, &quot;days&quot; -&gt; {
<span class="fc" id="L283">        return &quot;d&quot;;</span>
      }
      case &quot;w&quot;, &quot;wk&quot;, &quot;wks&quot;, &quot;week&quot;, &quot;weeks&quot; -&gt; {
<span class="nc" id="L286">        return &quot;w&quot;;</span>
      }
      case &quot;mon&quot;, &quot;month&quot;, &quot;months&quot; -&gt; {
<span class="fc" id="L289">        return &quot;M&quot;; // month</span>
      }
      case &quot;y&quot;, &quot;yr&quot;, &quot;yrs&quot;, &quot;year&quot;, &quot;years&quot; -&gt; {
<span class="fc" id="L292">        return &quot;y&quot;;</span>
      }
      case &quot;q&quot;, &quot;qtr&quot;, &quot;qtrs&quot;, &quot;quarter&quot;, &quot;quarters&quot; -&gt; {
<span class="fc" id="L295">        return &quot;q&quot;;</span>
      }
      default -&gt; {
<span class="fc" id="L298">        String lower = rawUnit.toLowerCase();</span>
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">        if (lower.matches(&quot;w[0-7]&quot;)) return lower;</span>
<span class="nc" id="L300">        throw new IllegalArgumentException(&quot;Unsupported unit alias: &quot; + rawUnit);</span>
      }
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>