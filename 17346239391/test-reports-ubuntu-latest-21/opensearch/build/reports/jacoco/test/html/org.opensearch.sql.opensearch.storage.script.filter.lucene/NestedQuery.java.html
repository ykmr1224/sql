<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NestedQuery.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">opensearch</a> &gt; <a href="index.source.html" class="el_package">org.opensearch.sql.opensearch.storage.script.filter.lucene</a> &gt; <span class="el_source">NestedQuery.java</span></div><h1>NestedQuery.java</h1><pre class="source lang-java linenums">/*
 * Copyright OpenSearch Contributors
 * SPDX-License-Identifier: Apache-2.0
 */

package org.opensearch.sql.opensearch.storage.script.filter.lucene;

import org.apache.lucene.search.join.ScoreMode;
import org.opensearch.index.query.QueryBuilder;
import org.opensearch.index.query.QueryBuilders;
import org.opensearch.sql.data.model.ExprValue;
import org.opensearch.sql.expression.Expression;
import org.opensearch.sql.expression.FunctionExpression;
import org.opensearch.sql.expression.LiteralExpression;
import org.opensearch.sql.expression.ReferenceExpression;

/** Lucene query that build nested query. */
<span class="fc" id="L18">public class NestedQuery extends LuceneQuery {</span>

  /**
   * Build query for 'nested' function used in predicate expression. Supports 'nested' function on
   * left and literal on right.
   *
   * @param func Function expression.
   * @param innerQuery Comparison query to be place inside nested query.
   * @return Nested query.
   */
  public QueryBuilder buildNested(FunctionExpression func, LuceneQuery innerQuery) {
    // Generate inner query for placement inside nested query
<span class="fc" id="L30">    FunctionExpression nestedFunc = (FunctionExpression) func.getArguments().get(0);</span>
<span class="fc" id="L31">    validateArgs(nestedFunc, func.getArguments().get(1));</span>
<span class="fc" id="L32">    ExprValue literalValue = func.getArguments().get(1).valueOf();</span>
<span class="fc" id="L33">    ReferenceExpression ref = (ReferenceExpression) nestedFunc.getArguments().get(0);</span>
<span class="fc" id="L34">    QueryBuilder innerQueryResult =</span>
<span class="fc" id="L35">        innerQuery.doBuild(ref.getAttr(), nestedFunc.type(), literalValue);</span>

    // Generate nested query
<span class="fc bfc" id="L38" title="All 2 branches covered.">    boolean hasPathParam = nestedFunc.getArguments().size() == 2;</span>
    String pathStr =
<span class="fc bfc" id="L40" title="All 2 branches covered.">        hasPathParam</span>
<span class="fc" id="L41">            ? nestedFunc.getArguments().get(1).toString()</span>
<span class="fc" id="L42">            : getNestedPathString((ReferenceExpression) nestedFunc.getArguments().get(0));</span>
<span class="fc" id="L43">    return QueryBuilders.nestedQuery(pathStr, innerQueryResult, ScoreMode.None);</span>
  }

  /**
   * Dynamically generate path for nested field. An example field of 'office.section.cubicle' would
   * dynamically generate the path 'office.section'.
   *
   * @param field nested field to generate path for.
   * @return path for nested field.
   */
  private String getNestedPathString(ReferenceExpression field) {
<span class="fc" id="L54">    String ret = &quot;&quot;;</span>
<span class="fc bfc" id="L55" title="All 2 branches covered.">    for (int i = 0; i &lt; field.getPaths().size() - 1; i++) {</span>
<span class="fc bfc" id="L56" title="All 2 branches covered.">      ret += (i == 0) ? field.getPaths().get(i) : &quot;.&quot; + field.getPaths().get(i);</span>
    }
<span class="fc" id="L58">    return ret;</span>
  }

  /**
   * Validate arguments in nested function and predicate expression.
   *
   * @param nestedFunc Nested function expression.
   */
  private void validateArgs(FunctionExpression nestedFunc, Expression rightExpression) {
<span class="fc bfc" id="L67" title="All 2 branches covered.">    if (nestedFunc.getArguments().size() &gt; 2) {</span>
<span class="fc" id="L68">      throw new IllegalArgumentException(</span>
          &quot;nested function supports 2 parameters (field, path) or 1 parameter (field)&quot;);
    }

<span class="fc bfc" id="L72" title="All 2 branches covered.">    for (var arg : nestedFunc.getArguments()) {</span>
<span class="fc bfc" id="L73" title="All 2 branches covered.">      if (!(arg instanceof ReferenceExpression)) {</span>
<span class="fc" id="L74">        throw new IllegalArgumentException(</span>
<span class="fc" id="L75">            String.format(&quot;Illegal nested field name: %s&quot;, arg.toString()));</span>
      }
<span class="fc" id="L77">    }</span>

<span class="fc bfc" id="L79" title="All 2 branches covered.">    if (!(rightExpression instanceof LiteralExpression)) {</span>
<span class="fc" id="L80">      throw new IllegalArgumentException(</span>
<span class="fc" id="L81">          String.format(</span>
              &quot;Illegal argument on right side of predicate expression: %s&quot;,
<span class="fc" id="L83">              rightExpression.toString()));</span>
    }
<span class="fc" id="L85">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>