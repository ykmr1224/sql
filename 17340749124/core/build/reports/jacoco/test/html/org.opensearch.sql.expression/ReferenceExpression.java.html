<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReferenceExpression.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">core</a> &gt; <a href="index.source.html" class="el_package">org.opensearch.sql.expression</a> &gt; <span class="el_source">ReferenceExpression.java</span></div><h1>ReferenceExpression.java</h1><pre class="source lang-java linenums">/*
 * Copyright OpenSearch Contributors
 * SPDX-License-Identifier: Apache-2.0
 */

package org.opensearch.sql.expression;

import java.util.Arrays;
import java.util.List;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import org.opensearch.sql.data.model.ExprTupleValue;
import org.opensearch.sql.data.model.ExprValue;
import org.opensearch.sql.data.model.ExprValueUtils;
import org.opensearch.sql.data.type.ExprType;
import org.opensearch.sql.expression.env.Environment;

@EqualsAndHashCode
@RequiredArgsConstructor
public class ReferenceExpression implements Expression {
  @Getter private final String attr;

  @Getter private final String rawPath;

  @Getter private final List&lt;String&gt; paths;

  @Getter private final ExprType type;

  /**
   * Constructor of ReferenceExpression.
   *
   * @param ref the field name. e.g. addr.state/addr.
   * @param type type.
   */
<span class="fc" id="L36">  public ReferenceExpression(String ref, ExprType type) {</span>
<span class="fc" id="L37">    this.attr = ref;</span>
    // Todo. the define of paths need to be redefined after adding multiple index/variable support.
    // For AliasType, the actual path is set in the property of `path` and the type is derived
    // from the type of field on that path; Otherwise, use ref itself as the path
<span class="fc" id="L41">    this.rawPath = type.getOriginalPath().orElse(ref);</span>
<span class="fc" id="L42">    this.paths = Arrays.asList(rawPath.split(&quot;\\.&quot;));</span>
<span class="fc" id="L43">    this.type = type.getOriginalExprType();</span>
<span class="fc" id="L44">  }</span>

  @Override
  public ExprValue valueOf(Environment&lt;Expression, ExprValue&gt; env) {
<span class="fc" id="L48">    return env.resolve(this);</span>
  }

  @Override
  public ExprType type() {
<span class="fc" id="L53">    return type;</span>
  }

  @Override
  public &lt;T, C&gt; T accept(ExpressionNodeVisitor&lt;T, C&gt; visitor, C context) {
<span class="fc" id="L58">    return visitor.visitReference(this, context);</span>
  }

  @Override
  public String toString() {
<span class="fc" id="L63">    return attr;</span>
  }

  /**
   * &lt;pre&gt;
   * Resolve the ExprValue from {@link ExprTupleValue} using paths.
   * Considering the following sample data.
   * {
   *   &quot;name&quot;: &quot;bob smith&quot;
   *   &quot;project.year&quot;: 1990,
   *   &quot;project&quot;: {
   *     &quot;year&quot;: &quot;2020&quot;
   *   }
   *   &quot;address&quot;: {
   *     &quot;state&quot;: &quot;WA&quot;,
   *     &quot;city&quot;: &quot;seattle&quot;,
   *     &quot;project.year&quot;: 1990
   *   }
   *   &quot;address.local&quot;: {
   *     &quot;state&quot;: &quot;WA&quot;,
   *   }
   * }
   * The paths could be
   * 1. top level, e.g. &quot;name&quot;, which will be resolved as &quot;bob smith&quot;
   * 2. multiple paths, e.g. &quot;name.address.state&quot;, which will be resolved as &quot;WA&quot;
   * 3. special case, the &quot;.&quot; is the path separator, but it is possible that the path include
   * &quot;.&quot;, for handling this use case, we define the resolve rule as bellow, e.g. &quot;project.year&quot; is
   * resolved as 1990 instead of 2020. Note. This logic only applied top level none object field.
   * e.g. &quot;address.local.state&quot; been resolved to Missing. but &quot;address.project.year&quot; could been
   * resolved as 1990.
   *
   * &lt;p&gt;Resolve Rule
   * 1. Resolve the full name by combine the paths(&quot;x&quot;.&quot;y&quot;.&quot;z&quot;) as whole (&quot;x.y.z&quot;).
   * 2. Resolve the path recursively through ExprValue.
   *
   * @param value {@link ExprTupleValue}.
   * @return {@link ExprTupleValue}.
   * &lt;/pre&gt;
   */
  public ExprValue resolve(ExprTupleValue value) {
<span class="fc" id="L103">    return ExprValueUtils.resolveRefPaths(value, paths);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>