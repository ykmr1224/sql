<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TrendlineOperator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">core</a> &gt; <a href="index.source.html" class="el_package">org.opensearch.sql.planner.physical</a> &gt; <span class="el_source">TrendlineOperator.java</span></div><h1>TrendlineOperator.java</h1><pre class="source lang-java linenums">/*
 * Copyright OpenSearch Contributors
 * SPDX-License-Identifier: Apache-2.0
 */

package org.opensearch.sql.planner.physical;

import static java.time.temporal.ChronoUnit.MILLIS;

import com.google.common.collect.EvictingQueue;
import com.google.common.collect.ImmutableMap.Builder;
import java.time.Instant;
import java.time.LocalTime;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;
import org.apache.commons.lang3.tuple.Pair;
import org.opensearch.sql.ast.tree.Trendline;
import org.opensearch.sql.data.model.ExprTupleValue;
import org.opensearch.sql.data.model.ExprValue;
import org.opensearch.sql.data.model.ExprValueUtils;
import org.opensearch.sql.data.type.ExprCoreType;
import org.opensearch.sql.expression.DSL;
import org.opensearch.sql.expression.Expression;
import org.opensearch.sql.expression.LiteralExpression;

/** Trendline command implementation */
@ToString
@EqualsAndHashCode(callSuper = false)
public class TrendlineOperator extends PhysicalPlan {
  @Getter private final PhysicalPlan input;
  @Getter private final List&lt;Pair&lt;Trendline.TrendlineComputation, ExprCoreType&gt;&gt; computations;
  @EqualsAndHashCode.Exclude private final List&lt;TrendlineAccumulator&gt; accumulators;
  @EqualsAndHashCode.Exclude private final Map&lt;String, Integer&gt; fieldToIndexMap;
  @EqualsAndHashCode.Exclude private final HashSet&lt;String&gt; aliases;

  public TrendlineOperator(
<span class="fc" id="L43">      PhysicalPlan input, List&lt;Pair&lt;Trendline.TrendlineComputation, ExprCoreType&gt;&gt; computations) {</span>
<span class="fc" id="L44">    this.input = input;</span>
<span class="fc" id="L45">    this.computations = computations;</span>
<span class="fc" id="L46">    this.accumulators = computations.stream().map(TrendlineOperator::createAccumulator).toList();</span>
<span class="fc" id="L47">    fieldToIndexMap = new HashMap&lt;&gt;(computations.size());</span>
<span class="fc" id="L48">    aliases = new HashSet&lt;&gt;(computations.size());</span>
<span class="fc bfc" id="L49" title="All 2 branches covered.">    for (int i = 0; i &lt; computations.size(); ++i) {</span>
<span class="fc" id="L50">      final Trendline.TrendlineComputation computation = computations.get(i).getKey();</span>
<span class="fc" id="L51">      fieldToIndexMap.put(computation.getDataField().getChild().get(0).toString(), i);</span>
<span class="fc" id="L52">      aliases.add(computation.getAlias());</span>
    }
<span class="fc" id="L54">  }</span>

  @Override
  public &lt;R, C&gt; R accept(PhysicalPlanNodeVisitor&lt;R, C&gt; visitor, C context) {
<span class="fc" id="L58">    return visitor.visitTrendline(this, context);</span>
  }

  @Override
  public List&lt;PhysicalPlan&gt; getChild() {
<span class="fc" id="L63">    return Collections.singletonList(input);</span>
  }

  @Override
  public boolean hasNext() {
<span class="fc" id="L68">    return getChild().getFirst().hasNext();</span>
  }

  @Override
  public ExprValue next() {
    final ExprValue result;
<span class="fc" id="L74">    final ExprValue next = input.next();</span>
<span class="fc" id="L75">    final Map&lt;String, ExprValue&gt; inputStruct = consumeInputTuple(next);</span>
<span class="fc" id="L76">    final Builder&lt;String, ExprValue&gt; mapBuilder = new Builder&lt;&gt;();</span>
<span class="fc" id="L77">    mapBuilder.putAll(inputStruct);</span>

    // Add calculated trendline values, which might overwrite existing fields from the input.
<span class="fc bfc" id="L80" title="All 2 branches covered.">    for (int i = 0; i &lt; accumulators.size(); ++i) {</span>
<span class="fc" id="L81">      final ExprValue calculateResult = accumulators.get(i).calculate();</span>
<span class="fc" id="L82">      final String field = computations.get(i).getKey().getAlias();</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">      if (calculateResult != null) {</span>
<span class="fc" id="L84">        mapBuilder.put(field, calculateResult);</span>
      }
    }

<span class="fc" id="L88">    result = ExprTupleValue.fromExprValueMap(mapBuilder.buildKeepingLast());</span>
<span class="fc" id="L89">    return result;</span>
  }

  private Map&lt;String, ExprValue&gt; consumeInputTuple(ExprValue inputValue) {
<span class="fc" id="L93">    final Map&lt;String, ExprValue&gt; tupleValue = ExprValueUtils.getTupleValue(inputValue);</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">    for (String bindName : tupleValue.keySet()) {</span>
<span class="fc" id="L95">      final Integer index = fieldToIndexMap.get(bindName);</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">      if (index != null) {</span>
<span class="fc" id="L97">        final ExprValue fieldValue = tupleValue.get(bindName);</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">        if (!fieldValue.isNull()) {</span>
<span class="fc" id="L99">          accumulators.get(index).accumulate(fieldValue);</span>
        }
      }
<span class="fc" id="L102">    }</span>
<span class="fc" id="L103">    tupleValue.keySet().removeAll(aliases);</span>
<span class="fc" id="L104">    return tupleValue;</span>
  }

  private static TrendlineAccumulator createAccumulator(
      Pair&lt;Trendline.TrendlineComputation, ExprCoreType&gt; computation) {
    // Add a switch statement based on computation type to choose the accumulator when more
    // types of computations are supported.
<span class="fc" id="L111">    return new SimpleMovingAverageAccumulator(computation.getKey(), computation.getValue());</span>
  }

  /** Maintains stateful information for calculating the trendline. */
  private interface TrendlineAccumulator {
    void accumulate(ExprValue value);

    ExprValue calculate();

    static ArithmeticEvaluator getEvaluator(ExprCoreType type) {
<span class="fc bfc" id="L121" title="All 5 branches covered.">      switch (type) {</span>
        case DOUBLE:
<span class="fc" id="L123">          return NumericArithmeticEvaluator.INSTANCE;</span>
        case DATE:
<span class="fc" id="L125">          return DateArithmeticEvaluator.INSTANCE;</span>
        case TIME:
<span class="fc" id="L127">          return TimeArithmeticEvaluator.INSTANCE;</span>
        case TIMESTAMP:
<span class="fc" id="L129">          return TimestampArithmeticEvaluator.INSTANCE;</span>
      }
<span class="fc" id="L131">      throw new IllegalArgumentException(</span>
<span class="fc" id="L132">          String.format(&quot;Invalid type %s used for moving average.&quot;, type.typeName()));</span>
    }
  }

  private static class SimpleMovingAverageAccumulator implements TrendlineAccumulator {
    private final LiteralExpression dataPointsNeeded;
    private final EvictingQueue&lt;ExprValue&gt; receivedValues;
    private final ArithmeticEvaluator evaluator;
<span class="fc" id="L140">    private Expression runningTotal = null;</span>

    public SimpleMovingAverageAccumulator(
<span class="fc" id="L143">        Trendline.TrendlineComputation computation, ExprCoreType type) {</span>
<span class="fc" id="L144">      dataPointsNeeded = DSL.literal(computation.getNumberOfDataPoints().doubleValue());</span>
<span class="fc" id="L145">      receivedValues = EvictingQueue.create(computation.getNumberOfDataPoints());</span>
<span class="fc" id="L146">      evaluator = TrendlineAccumulator.getEvaluator(type);</span>
<span class="fc" id="L147">    }</span>

    @Override
    public void accumulate(ExprValue value) {
<span class="fc bfc" id="L151" title="All 2 branches covered.">      if (dataPointsNeeded.valueOf().integerValue() == 1) {</span>
<span class="fc" id="L152">        runningTotal = evaluator.calculateFirstTotal(Collections.singletonList(value));</span>
<span class="fc" id="L153">        receivedValues.add(value);</span>
<span class="fc" id="L154">        return;</span>
      }

      final ExprValue valueToRemove;
<span class="fc bfc" id="L158" title="All 2 branches covered.">      if (receivedValues.size() == dataPointsNeeded.valueOf().integerValue()) {</span>
<span class="fc" id="L159">        valueToRemove = receivedValues.remove();</span>
      } else {
<span class="fc" id="L161">        valueToRemove = null;</span>
      }
<span class="fc" id="L163">      receivedValues.add(value);</span>

<span class="fc bfc" id="L165" title="All 2 branches covered.">      if (receivedValues.size() == dataPointsNeeded.valueOf().integerValue()) {</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">        if (runningTotal != null) {</span>
          // We can use the previous calculation.
          // Subtract the evicted value and add the new value.
          // Refactored, that would be previous + (newValue - oldValue).
<span class="fc" id="L170">          runningTotal = evaluator.add(runningTotal, value, valueToRemove);</span>
        } else {
          // This is the first average calculation so sum the entire receivedValues dataset.
<span class="fc" id="L173">          final List&lt;ExprValue&gt; data = receivedValues.stream().toList();</span>
<span class="fc" id="L174">          runningTotal = evaluator.calculateFirstTotal(data);</span>
        }
      }
<span class="fc" id="L177">    }</span>

    @Override
    public ExprValue calculate() {
<span class="fc bfc" id="L181" title="All 2 branches covered.">      if (receivedValues.size() &lt; dataPointsNeeded.valueOf().integerValue()) {</span>
<span class="fc" id="L182">        return null;</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">      } else if (dataPointsNeeded.valueOf().integerValue() == 1) {</span>
<span class="fc" id="L184">        return receivedValues.peek();</span>
      }
<span class="fc" id="L186">      return evaluator.evaluate(runningTotal, dataPointsNeeded);</span>
    }
  }

  private interface ArithmeticEvaluator {
    Expression calculateFirstTotal(List&lt;ExprValue&gt; dataPoints);

    Expression add(Expression runningTotal, ExprValue incomingValue, ExprValue evictedValue);

    ExprValue evaluate(Expression runningTotal, LiteralExpression numberOfDataPoints);
  }

  private static class NumericArithmeticEvaluator implements ArithmeticEvaluator {
<span class="fc" id="L199">    private static final NumericArithmeticEvaluator INSTANCE = new NumericArithmeticEvaluator();</span>

    private NumericArithmeticEvaluator() {}

    @Override
    public Expression calculateFirstTotal(List&lt;ExprValue&gt; dataPoints) {
<span class="fc" id="L205">      Expression total = DSL.literal(0.0D);</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">      for (ExprValue dataPoint : dataPoints) {</span>
<span class="fc" id="L207">        total = DSL.add(total, DSL.literal(dataPoint.doubleValue()));</span>
<span class="fc" id="L208">      }</span>
<span class="fc" id="L209">      return DSL.literal(total.valueOf().doubleValue());</span>
    }

    @Override
    public Expression add(
        Expression runningTotal, ExprValue incomingValue, ExprValue evictedValue) {
<span class="fc" id="L215">      return DSL.literal(</span>
<span class="fc" id="L216">          DSL.add(runningTotal, DSL.subtract(DSL.literal(incomingValue), DSL.literal(evictedValue)))</span>
<span class="fc" id="L217">              .valueOf()</span>
<span class="fc" id="L218">              .doubleValue());</span>
    }

    @Override
    public ExprValue evaluate(Expression runningTotal, LiteralExpression numberOfDataPoints) {
<span class="fc" id="L223">      return DSL.divide(runningTotal, numberOfDataPoints).valueOf();</span>
    }
  }

  private static class DateArithmeticEvaluator implements ArithmeticEvaluator {
<span class="fc" id="L228">    private static final DateArithmeticEvaluator INSTANCE = new DateArithmeticEvaluator();</span>

    private DateArithmeticEvaluator() {}

    @Override
    public Expression calculateFirstTotal(List&lt;ExprValue&gt; dataPoints) {
<span class="fc" id="L234">      return TimestampArithmeticEvaluator.INSTANCE.calculateFirstTotal(dataPoints);</span>
    }

    @Override
    public Expression add(
        Expression runningTotal, ExprValue incomingValue, ExprValue evictedValue) {
<span class="fc" id="L240">      return TimestampArithmeticEvaluator.INSTANCE.add(runningTotal, incomingValue, evictedValue);</span>
    }

    @Override
    public ExprValue evaluate(Expression runningTotal, LiteralExpression numberOfDataPoints) {
<span class="fc" id="L245">      final ExprValue timestampResult =</span>
<span class="fc" id="L246">          TimestampArithmeticEvaluator.INSTANCE.evaluate(runningTotal, numberOfDataPoints);</span>
<span class="fc" id="L247">      return ExprValueUtils.dateValue(timestampResult.dateValue());</span>
    }
  }

  private static class TimeArithmeticEvaluator implements ArithmeticEvaluator {
<span class="fc" id="L252">    private static final TimeArithmeticEvaluator INSTANCE = new TimeArithmeticEvaluator();</span>

    private TimeArithmeticEvaluator() {}

    @Override
    public Expression calculateFirstTotal(List&lt;ExprValue&gt; dataPoints) {
<span class="fc" id="L258">      Expression total = DSL.literal(0);</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">      for (ExprValue dataPoint : dataPoints) {</span>
<span class="fc" id="L260">        total = DSL.add(total, DSL.literal(MILLIS.between(LocalTime.MIN, dataPoint.timeValue())));</span>
<span class="fc" id="L261">      }</span>
<span class="fc" id="L262">      return DSL.literal(total.valueOf().longValue());</span>
    }

    @Override
    public Expression add(
        Expression runningTotal, ExprValue incomingValue, ExprValue evictedValue) {
<span class="fc" id="L268">      return DSL.literal(</span>
<span class="fc" id="L269">          DSL.add(</span>
                  runningTotal,
<span class="fc" id="L271">                  DSL.subtract(</span>
<span class="fc" id="L272">                      DSL.literal(MILLIS.between(LocalTime.MIN, incomingValue.timeValue())),</span>
<span class="fc" id="L273">                      DSL.literal(MILLIS.between(LocalTime.MIN, evictedValue.timeValue()))))</span>
<span class="fc" id="L274">              .valueOf());</span>
    }

    @Override
    public ExprValue evaluate(Expression runningTotal, LiteralExpression numberOfDataPoints) {
<span class="fc" id="L279">      return ExprValueUtils.timeValue(</span>
<span class="fc" id="L280">          LocalTime.MIN.plus(</span>
<span class="fc" id="L281">              DSL.divide(runningTotal, numberOfDataPoints).valueOf().longValue(), MILLIS));</span>
    }
  }

  private static class TimestampArithmeticEvaluator implements ArithmeticEvaluator {
<span class="fc" id="L286">    private static final TimestampArithmeticEvaluator INSTANCE = new TimestampArithmeticEvaluator();</span>

    private TimestampArithmeticEvaluator() {}

    @Override
    public Expression calculateFirstTotal(List&lt;ExprValue&gt; dataPoints) {
<span class="fc" id="L292">      Expression total = DSL.literal(0);</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">      for (ExprValue dataPoint : dataPoints) {</span>
<span class="fc" id="L294">        total = DSL.add(total, DSL.literal(dataPoint.timestampValue().toEpochMilli()));</span>
<span class="fc" id="L295">      }</span>
<span class="fc" id="L296">      return DSL.literal(total.valueOf().longValue());</span>
    }

    @Override
    public Expression add(
        Expression runningTotal, ExprValue incomingValue, ExprValue evictedValue) {
<span class="fc" id="L302">      return DSL.literal(</span>
<span class="fc" id="L303">          DSL.add(</span>
                  runningTotal,
<span class="fc" id="L305">                  DSL.subtract(</span>
<span class="fc" id="L306">                      DSL.literal(incomingValue.timestampValue().toEpochMilli()),</span>
<span class="fc" id="L307">                      DSL.literal(evictedValue.timestampValue().toEpochMilli())))</span>
<span class="fc" id="L308">              .valueOf());</span>
    }

    @Override
    public ExprValue evaluate(Expression runningTotal, LiteralExpression numberOfDataPoints) {
<span class="fc" id="L313">      return ExprValueUtils.timestampValue(</span>
<span class="fc" id="L314">          Instant.ofEpochMilli(DSL.divide(runningTotal, numberOfDataPoints).valueOf().longValue()));</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>