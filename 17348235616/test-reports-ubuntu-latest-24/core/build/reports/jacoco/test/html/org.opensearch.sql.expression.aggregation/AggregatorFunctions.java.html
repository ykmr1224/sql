<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AggregatorFunctions.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">core</a> &gt; <a href="index.source.html" class="el_package">org.opensearch.sql.expression.aggregation</a> &gt; <span class="el_source">AggregatorFunctions.java</span></div><h1>AggregatorFunctions.java</h1><pre class="source lang-java linenums">/*
 * Copyright OpenSearch Contributors
 * SPDX-License-Identifier: Apache-2.0
 */

package org.opensearch.sql.expression.aggregation;

import static org.opensearch.sql.data.type.ExprCoreType.ARRAY;
import static org.opensearch.sql.data.type.ExprCoreType.DATE;
import static org.opensearch.sql.data.type.ExprCoreType.DOUBLE;
import static org.opensearch.sql.data.type.ExprCoreType.FLOAT;
import static org.opensearch.sql.data.type.ExprCoreType.INTEGER;
import static org.opensearch.sql.data.type.ExprCoreType.LONG;
import static org.opensearch.sql.data.type.ExprCoreType.STRING;
import static org.opensearch.sql.data.type.ExprCoreType.TIME;
import static org.opensearch.sql.data.type.ExprCoreType.TIMESTAMP;
import static org.opensearch.sql.expression.aggregation.StdDevAggregator.stddevPopulation;
import static org.opensearch.sql.expression.aggregation.StdDevAggregator.stddevSample;
import static org.opensearch.sql.expression.aggregation.VarianceAggregator.variancePopulation;
import static org.opensearch.sql.expression.aggregation.VarianceAggregator.varianceSample;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import java.util.Collections;
import java.util.stream.Collectors;
import lombok.experimental.UtilityClass;
import org.opensearch.sql.data.type.ExprCoreType;
import org.opensearch.sql.expression.function.BuiltinFunctionName;
import org.opensearch.sql.expression.function.BuiltinFunctionRepository;
import org.opensearch.sql.expression.function.DefaultFunctionResolver;
import org.opensearch.sql.expression.function.FunctionBuilder;
import org.opensearch.sql.expression.function.FunctionName;
import org.opensearch.sql.expression.function.FunctionSignature;

/**
 * The definition of aggregator functions &lt;em&gt;avg&lt;/em&gt;, &lt;em&gt;sum&lt;/em&gt;, &lt;em&gt;min&lt;/em&gt;, &lt;em&gt;max&lt;/em&gt; and
 * &lt;em&gt;count&lt;/em&gt;.&lt;br&gt;
 * All of them accept a list of numbers and produce a number. &lt;em&gt;avg&lt;/em&gt;, &lt;em&gt;min&lt;/em&gt; and
 * &lt;em&gt;max&lt;/em&gt; also accept datetime types.&lt;br&gt;
 * &lt;em&gt;count&lt;/em&gt; accepts values of all types.
 */
@UtilityClass
public class AggregatorFunctions {
  /**
   * Register Aggregation Function.
   *
   * @param repository {@link BuiltinFunctionRepository}.
   */
  public static void register(BuiltinFunctionRepository repository) {
<span class="fc" id="L50">    repository.register(avg());</span>
<span class="fc" id="L51">    repository.register(sum());</span>
<span class="fc" id="L52">    repository.register(count());</span>
<span class="fc" id="L53">    repository.register(min());</span>
<span class="fc" id="L54">    repository.register(max());</span>
<span class="fc" id="L55">    repository.register(varSamp());</span>
<span class="fc" id="L56">    repository.register(varPop());</span>
<span class="fc" id="L57">    repository.register(stddevSamp());</span>
<span class="fc" id="L58">    repository.register(stddevPop());</span>
<span class="fc" id="L59">    repository.register(take());</span>
<span class="fc" id="L60">    repository.register(percentileApprox());</span>
<span class="fc" id="L61">  }</span>

  private static DefaultFunctionResolver avg() {
<span class="fc" id="L64">    FunctionName functionName = BuiltinFunctionName.AVG.getName();</span>
<span class="fc" id="L65">    return new DefaultFunctionResolver(</span>
        functionName,
        new ImmutableMap.Builder&lt;FunctionSignature, FunctionBuilder&gt;()
<span class="fc" id="L68">            .put(</span>
<span class="fc" id="L69">                new FunctionSignature(functionName, Collections.singletonList(DOUBLE)),</span>
<span class="fc" id="L70">                (functionProperties, arguments) -&gt; new AvgAggregator(arguments, DOUBLE))</span>
<span class="fc" id="L71">            .put(</span>
<span class="fc" id="L72">                new FunctionSignature(functionName, Collections.singletonList(DATE)),</span>
<span class="fc" id="L73">                (functionProperties, arguments) -&gt; new AvgAggregator(arguments, DATE))</span>
<span class="fc" id="L74">            .put(</span>
<span class="fc" id="L75">                new FunctionSignature(functionName, Collections.singletonList(TIME)),</span>
<span class="fc" id="L76">                (functionProperties, arguments) -&gt; new AvgAggregator(arguments, TIME))</span>
<span class="fc" id="L77">            .put(</span>
<span class="fc" id="L78">                new FunctionSignature(functionName, Collections.singletonList(TIMESTAMP)),</span>
<span class="fc" id="L79">                (functionProperties, arguments) -&gt; new AvgAggregator(arguments, TIMESTAMP))</span>
<span class="fc" id="L80">            .build());</span>
  }

  private static DefaultFunctionResolver count() {
<span class="fc" id="L84">    FunctionName functionName = BuiltinFunctionName.COUNT.getName();</span>
<span class="fc" id="L85">    DefaultFunctionResolver functionResolver =</span>
        new DefaultFunctionResolver(
            functionName,
<span class="fc" id="L88">            ExprCoreType.coreTypes().stream()</span>
<span class="fc" id="L89">                .collect(</span>
<span class="fc" id="L90">                    Collectors.toMap(</span>
                        type -&gt;
<span class="fc" id="L92">                            new FunctionSignature(functionName, Collections.singletonList(type)),</span>
                        type -&gt;
<span class="fc" id="L94">                            (functionProperties, arguments) -&gt;</span>
<span class="fc" id="L95">                                new CountAggregator(arguments, INTEGER))));</span>
<span class="fc" id="L96">    return functionResolver;</span>
  }

  private static DefaultFunctionResolver sum() {
<span class="fc" id="L100">    FunctionName functionName = BuiltinFunctionName.SUM.getName();</span>
<span class="fc" id="L101">    return new DefaultFunctionResolver(</span>
        functionName,
        new ImmutableMap.Builder&lt;FunctionSignature, FunctionBuilder&gt;()
<span class="fc" id="L104">            .put(</span>
<span class="fc" id="L105">                new FunctionSignature(functionName, Collections.singletonList(INTEGER)),</span>
<span class="fc" id="L106">                (functionProperties, arguments) -&gt; new SumAggregator(arguments, INTEGER))</span>
<span class="fc" id="L107">            .put(</span>
<span class="fc" id="L108">                new FunctionSignature(functionName, Collections.singletonList(LONG)),</span>
<span class="fc" id="L109">                (functionProperties, arguments) -&gt; new SumAggregator(arguments, LONG))</span>
<span class="fc" id="L110">            .put(</span>
<span class="fc" id="L111">                new FunctionSignature(functionName, Collections.singletonList(FLOAT)),</span>
<span class="fc" id="L112">                (functionProperties, arguments) -&gt; new SumAggregator(arguments, FLOAT))</span>
<span class="fc" id="L113">            .put(</span>
<span class="fc" id="L114">                new FunctionSignature(functionName, Collections.singletonList(DOUBLE)),</span>
<span class="fc" id="L115">                (functionProperties, arguments) -&gt; new SumAggregator(arguments, DOUBLE))</span>
<span class="fc" id="L116">            .build());</span>
  }

  private static DefaultFunctionResolver min() {
<span class="fc" id="L120">    FunctionName functionName = BuiltinFunctionName.MIN.getName();</span>
<span class="fc" id="L121">    return new DefaultFunctionResolver(</span>
        functionName,
        new ImmutableMap.Builder&lt;FunctionSignature, FunctionBuilder&gt;()
<span class="fc" id="L124">            .put(</span>
<span class="fc" id="L125">                new FunctionSignature(functionName, Collections.singletonList(INTEGER)),</span>
<span class="fc" id="L126">                (functionProperties, arguments) -&gt; new MinAggregator(arguments, INTEGER))</span>
<span class="fc" id="L127">            .put(</span>
<span class="fc" id="L128">                new FunctionSignature(functionName, Collections.singletonList(LONG)),</span>
<span class="fc" id="L129">                (functionProperties, arguments) -&gt; new MinAggregator(arguments, LONG))</span>
<span class="fc" id="L130">            .put(</span>
<span class="fc" id="L131">                new FunctionSignature(functionName, Collections.singletonList(FLOAT)),</span>
<span class="fc" id="L132">                (functionProperties, arguments) -&gt; new MinAggregator(arguments, FLOAT))</span>
<span class="fc" id="L133">            .put(</span>
<span class="fc" id="L134">                new FunctionSignature(functionName, Collections.singletonList(DOUBLE)),</span>
<span class="fc" id="L135">                (functionProperties, arguments) -&gt; new MinAggregator(arguments, DOUBLE))</span>
<span class="fc" id="L136">            .put(</span>
<span class="fc" id="L137">                new FunctionSignature(functionName, Collections.singletonList(STRING)),</span>
<span class="fc" id="L138">                (functionProperties, arguments) -&gt; new MinAggregator(arguments, STRING))</span>
<span class="fc" id="L139">            .put(</span>
<span class="fc" id="L140">                new FunctionSignature(functionName, Collections.singletonList(DATE)),</span>
<span class="fc" id="L141">                (functionProperties, arguments) -&gt; new MinAggregator(arguments, DATE))</span>
<span class="fc" id="L142">            .put(</span>
<span class="fc" id="L143">                new FunctionSignature(functionName, Collections.singletonList(TIME)),</span>
<span class="fc" id="L144">                (functionProperties, arguments) -&gt; new MinAggregator(arguments, TIME))</span>
<span class="fc" id="L145">            .put(</span>
<span class="fc" id="L146">                new FunctionSignature(functionName, Collections.singletonList(TIMESTAMP)),</span>
<span class="fc" id="L147">                (functionProperties, arguments) -&gt; new MinAggregator(arguments, TIMESTAMP))</span>
<span class="fc" id="L148">            .build());</span>
  }

  private static DefaultFunctionResolver max() {
<span class="fc" id="L152">    FunctionName functionName = BuiltinFunctionName.MAX.getName();</span>
<span class="fc" id="L153">    return new DefaultFunctionResolver(</span>
        functionName,
        new ImmutableMap.Builder&lt;FunctionSignature, FunctionBuilder&gt;()
<span class="fc" id="L156">            .put(</span>
<span class="fc" id="L157">                new FunctionSignature(functionName, Collections.singletonList(INTEGER)),</span>
<span class="fc" id="L158">                (functionProperties, arguments) -&gt; new MaxAggregator(arguments, INTEGER))</span>
<span class="fc" id="L159">            .put(</span>
<span class="fc" id="L160">                new FunctionSignature(functionName, Collections.singletonList(LONG)),</span>
<span class="fc" id="L161">                (functionProperties, arguments) -&gt; new MaxAggregator(arguments, LONG))</span>
<span class="fc" id="L162">            .put(</span>
<span class="fc" id="L163">                new FunctionSignature(functionName, Collections.singletonList(FLOAT)),</span>
<span class="fc" id="L164">                (functionProperties, arguments) -&gt; new MaxAggregator(arguments, FLOAT))</span>
<span class="fc" id="L165">            .put(</span>
<span class="fc" id="L166">                new FunctionSignature(functionName, Collections.singletonList(DOUBLE)),</span>
<span class="fc" id="L167">                (functionProperties, arguments) -&gt; new MaxAggregator(arguments, DOUBLE))</span>
<span class="fc" id="L168">            .put(</span>
<span class="fc" id="L169">                new FunctionSignature(functionName, Collections.singletonList(STRING)),</span>
<span class="fc" id="L170">                (functionProperties, arguments) -&gt; new MaxAggregator(arguments, STRING))</span>
<span class="fc" id="L171">            .put(</span>
<span class="fc" id="L172">                new FunctionSignature(functionName, Collections.singletonList(DATE)),</span>
<span class="fc" id="L173">                (functionProperties, arguments) -&gt; new MaxAggregator(arguments, DATE))</span>
<span class="fc" id="L174">            .put(</span>
<span class="fc" id="L175">                new FunctionSignature(functionName, Collections.singletonList(TIME)),</span>
<span class="fc" id="L176">                (functionProperties, arguments) -&gt; new MaxAggregator(arguments, TIME))</span>
<span class="fc" id="L177">            .put(</span>
<span class="fc" id="L178">                new FunctionSignature(functionName, Collections.singletonList(TIMESTAMP)),</span>
<span class="fc" id="L179">                (functionProperties, arguments) -&gt; new MaxAggregator(arguments, TIMESTAMP))</span>
<span class="fc" id="L180">            .build());</span>
  }

  private static DefaultFunctionResolver varSamp() {
<span class="fc" id="L184">    FunctionName functionName = BuiltinFunctionName.VARSAMP.getName();</span>
<span class="fc" id="L185">    return new DefaultFunctionResolver(</span>
        functionName,
        new ImmutableMap.Builder&lt;FunctionSignature, FunctionBuilder&gt;()
<span class="fc" id="L188">            .put(</span>
<span class="fc" id="L189">                new FunctionSignature(functionName, Collections.singletonList(DOUBLE)),</span>
<span class="fc" id="L190">                (functionProperties, arguments) -&gt; varianceSample(arguments, DOUBLE))</span>
<span class="fc" id="L191">            .build());</span>
  }

  private static DefaultFunctionResolver varPop() {
<span class="fc" id="L195">    FunctionName functionName = BuiltinFunctionName.VARPOP.getName();</span>
<span class="fc" id="L196">    return new DefaultFunctionResolver(</span>
        functionName,
        new ImmutableMap.Builder&lt;FunctionSignature, FunctionBuilder&gt;()
<span class="fc" id="L199">            .put(</span>
<span class="fc" id="L200">                new FunctionSignature(functionName, Collections.singletonList(DOUBLE)),</span>
<span class="fc" id="L201">                (functionProperties, arguments) -&gt; variancePopulation(arguments, DOUBLE))</span>
<span class="fc" id="L202">            .build());</span>
  }

  private static DefaultFunctionResolver stddevSamp() {
<span class="fc" id="L206">    FunctionName functionName = BuiltinFunctionName.STDDEV_SAMP.getName();</span>
<span class="fc" id="L207">    return new DefaultFunctionResolver(</span>
        functionName,
        new ImmutableMap.Builder&lt;FunctionSignature, FunctionBuilder&gt;()
<span class="fc" id="L210">            .put(</span>
<span class="fc" id="L211">                new FunctionSignature(functionName, Collections.singletonList(DOUBLE)),</span>
<span class="fc" id="L212">                (functionProperties, arguments) -&gt; stddevSample(arguments, DOUBLE))</span>
<span class="fc" id="L213">            .build());</span>
  }

  private static DefaultFunctionResolver stddevPop() {
<span class="fc" id="L217">    FunctionName functionName = BuiltinFunctionName.STDDEV_POP.getName();</span>
<span class="fc" id="L218">    return new DefaultFunctionResolver(</span>
        functionName,
        new ImmutableMap.Builder&lt;FunctionSignature, FunctionBuilder&gt;()
<span class="fc" id="L221">            .put(</span>
<span class="fc" id="L222">                new FunctionSignature(functionName, Collections.singletonList(DOUBLE)),</span>
<span class="fc" id="L223">                (functionProperties, arguments) -&gt; stddevPopulation(arguments, DOUBLE))</span>
<span class="fc" id="L224">            .build());</span>
  }

  private static DefaultFunctionResolver take() {
<span class="fc" id="L228">    FunctionName functionName = BuiltinFunctionName.TAKE.getName();</span>
<span class="fc" id="L229">    DefaultFunctionResolver functionResolver =</span>
        new DefaultFunctionResolver(
            functionName,
            new ImmutableMap.Builder&lt;FunctionSignature, FunctionBuilder&gt;()
<span class="fc" id="L233">                .put(</span>
<span class="fc" id="L234">                    new FunctionSignature(functionName, ImmutableList.of(STRING, INTEGER)),</span>
<span class="fc" id="L235">                    (functionProperties, arguments) -&gt; new TakeAggregator(arguments, ARRAY))</span>
<span class="fc" id="L236">                .build());</span>
<span class="fc" id="L237">    return functionResolver;</span>
  }

  private static DefaultFunctionResolver percentileApprox() {
<span class="fc" id="L241">    FunctionName functionName = BuiltinFunctionName.PERCENTILE_APPROX.getName();</span>
<span class="fc" id="L242">    DefaultFunctionResolver functionResolver =</span>
        new DefaultFunctionResolver(
            functionName,
            new ImmutableMap.Builder&lt;FunctionSignature, FunctionBuilder&gt;()
<span class="fc" id="L246">                .put(</span>
<span class="fc" id="L247">                    new FunctionSignature(functionName, ImmutableList.of(INTEGER, DOUBLE)),</span>
                    (functionProperties, arguments) -&gt;
<span class="fc" id="L249">                        PercentileApproximateAggregator.percentileApprox(arguments, INTEGER))</span>
<span class="fc" id="L250">                .put(</span>
<span class="fc" id="L251">                    new FunctionSignature(functionName, ImmutableList.of(INTEGER, DOUBLE, DOUBLE)),</span>
                    (functionProperties, arguments) -&gt;
<span class="fc" id="L253">                        PercentileApproximateAggregator.percentileApprox(arguments, INTEGER))</span>
<span class="fc" id="L254">                .put(</span>
<span class="fc" id="L255">                    new FunctionSignature(functionName, ImmutableList.of(LONG, DOUBLE)),</span>
                    (functionProperties, arguments) -&gt;
<span class="fc" id="L257">                        PercentileApproximateAggregator.percentileApprox(arguments, LONG))</span>
<span class="fc" id="L258">                .put(</span>
<span class="fc" id="L259">                    new FunctionSignature(functionName, ImmutableList.of(LONG, DOUBLE, DOUBLE)),</span>
                    (functionProperties, arguments) -&gt;
<span class="fc" id="L261">                        PercentileApproximateAggregator.percentileApprox(arguments, LONG))</span>
<span class="fc" id="L262">                .put(</span>
<span class="fc" id="L263">                    new FunctionSignature(functionName, ImmutableList.of(FLOAT, DOUBLE)),</span>
                    (functionProperties, arguments) -&gt;
<span class="fc" id="L265">                        PercentileApproximateAggregator.percentileApprox(arguments, FLOAT))</span>
<span class="fc" id="L266">                .put(</span>
<span class="fc" id="L267">                    new FunctionSignature(functionName, ImmutableList.of(FLOAT, DOUBLE, DOUBLE)),</span>
                    (functionProperties, arguments) -&gt;
<span class="fc" id="L269">                        PercentileApproximateAggregator.percentileApprox(arguments, FLOAT))</span>
<span class="fc" id="L270">                .put(</span>
<span class="fc" id="L271">                    new FunctionSignature(functionName, ImmutableList.of(DOUBLE, DOUBLE)),</span>
                    (functionProperties, arguments) -&gt;
<span class="fc" id="L273">                        PercentileApproximateAggregator.percentileApprox(arguments, DOUBLE))</span>
<span class="fc" id="L274">                .put(</span>
<span class="fc" id="L275">                    new FunctionSignature(functionName, ImmutableList.of(DOUBLE, DOUBLE, DOUBLE)),</span>
                    (functionProperties, arguments) -&gt;
<span class="fc" id="L277">                        PercentileApproximateAggregator.percentileApprox(arguments, DOUBLE))</span>
<span class="fc" id="L278">                .build());</span>
<span class="fc" id="L279">    return functionResolver;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>