<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TypeCastOperators.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">core</a> &gt; <a href="index.source.html" class="el_package">org.opensearch.sql.expression.operator.convert</a> &gt; <span class="el_source">TypeCastOperators.java</span></div><h1>TypeCastOperators.java</h1><pre class="source lang-java linenums">/*
 * Copyright OpenSearch Contributors
 * SPDX-License-Identifier: Apache-2.0
 */

package org.opensearch.sql.expression.operator.convert;

import static org.opensearch.sql.data.type.ExprCoreType.BOOLEAN;
import static org.opensearch.sql.data.type.ExprCoreType.BYTE;
import static org.opensearch.sql.data.type.ExprCoreType.DATE;
import static org.opensearch.sql.data.type.ExprCoreType.DOUBLE;
import static org.opensearch.sql.data.type.ExprCoreType.FLOAT;
import static org.opensearch.sql.data.type.ExprCoreType.INTEGER;
import static org.opensearch.sql.data.type.ExprCoreType.IP;
import static org.opensearch.sql.data.type.ExprCoreType.LONG;
import static org.opensearch.sql.data.type.ExprCoreType.SHORT;
import static org.opensearch.sql.data.type.ExprCoreType.STRING;
import static org.opensearch.sql.data.type.ExprCoreType.TIME;
import static org.opensearch.sql.data.type.ExprCoreType.TIMESTAMP;
import static org.opensearch.sql.data.type.ExprCoreType.UNDEFINED;
import static org.opensearch.sql.expression.function.FunctionDSL.impl;
import static org.opensearch.sql.expression.function.FunctionDSL.implWithProperties;
import static org.opensearch.sql.expression.function.FunctionDSL.nullMissingHandling;
import static org.opensearch.sql.expression.function.FunctionDSL.nullMissingHandlingWithProperties;

import java.util.Arrays;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import lombok.experimental.UtilityClass;
import org.opensearch.sql.data.model.ExprBooleanValue;
import org.opensearch.sql.data.model.ExprByteValue;
import org.opensearch.sql.data.model.ExprDateValue;
import org.opensearch.sql.data.model.ExprDoubleValue;
import org.opensearch.sql.data.model.ExprFloatValue;
import org.opensearch.sql.data.model.ExprIntegerValue;
import org.opensearch.sql.data.model.ExprIpValue;
import org.opensearch.sql.data.model.ExprLongValue;
import org.opensearch.sql.data.model.ExprShortValue;
import org.opensearch.sql.data.model.ExprStringValue;
import org.opensearch.sql.data.model.ExprTimeValue;
import org.opensearch.sql.data.model.ExprTimestampValue;
import org.opensearch.sql.expression.function.BuiltinFunctionName;
import org.opensearch.sql.expression.function.BuiltinFunctionRepository;
import org.opensearch.sql.expression.function.DefaultFunctionResolver;
import org.opensearch.sql.expression.function.FunctionDSL;
import org.opensearch.sql.utils.JsonUtils;

@UtilityClass
public class TypeCastOperators {

  /** Register Type Cast Operator. */
  public static void register(BuiltinFunctionRepository repository) {
<span class="fc" id="L53">    repository.register(castToString());</span>
<span class="fc" id="L54">    repository.register(castToByte());</span>
<span class="fc" id="L55">    repository.register(castToShort());</span>
<span class="fc" id="L56">    repository.register(castToInt());</span>
<span class="fc" id="L57">    repository.register(castToLong());</span>
<span class="fc" id="L58">    repository.register(castToFloat());</span>
<span class="fc" id="L59">    repository.register(castToDouble());</span>
<span class="fc" id="L60">    repository.register(castToBoolean());</span>
<span class="fc" id="L61">    repository.register(castToIp());</span>
<span class="fc" id="L62">    repository.register(castToJson());</span>
<span class="fc" id="L63">    repository.register(castToDate());</span>
<span class="fc" id="L64">    repository.register(castToTime());</span>
<span class="fc" id="L65">    repository.register(castToTimestamp());</span>
<span class="fc" id="L66">  }</span>

  private static DefaultFunctionResolver castToString() {
<span class="fc" id="L69">    return FunctionDSL.define(</span>
<span class="fc" id="L70">        BuiltinFunctionName.CAST_TO_STRING.getName(),</span>
<span class="fc" id="L71">        Stream.concat(</span>
<span class="fc" id="L72">                Arrays.asList(</span>
                        BYTE, SHORT, INTEGER, LONG, FLOAT, DOUBLE, BOOLEAN, TIME, DATE, TIMESTAMP)
<span class="fc" id="L74">                    .stream()</span>
<span class="fc" id="L75">                    .map(</span>
                        type -&gt;
<span class="fc" id="L77">                            impl(</span>
<span class="fc" id="L78">                                nullMissingHandling(</span>
<span class="fc" id="L79">                                    (v) -&gt; new ExprStringValue(v.value().toString())),</span>
                                STRING,
                                type)),
<span class="fc" id="L82">                Stream.of(impl(nullMissingHandling((v) -&gt; v), STRING, STRING)))</span>
<span class="fc" id="L83">            .collect(Collectors.toList()));</span>
  }

  private static DefaultFunctionResolver castToByte() {
<span class="fc" id="L87">    return FunctionDSL.define(</span>
<span class="fc" id="L88">        BuiltinFunctionName.CAST_TO_BYTE.getName(),</span>
<span class="fc" id="L89">        impl(</span>
<span class="fc" id="L90">            nullMissingHandling((v) -&gt; new ExprByteValue(Byte.valueOf(v.stringValue()))),</span>
            BYTE,
            STRING),
<span class="fc" id="L93">        impl(nullMissingHandling((v) -&gt; new ExprByteValue(v.byteValue())), BYTE, DOUBLE),</span>
<span class="fc" id="L94">        impl(</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">            nullMissingHandling((v) -&gt; new ExprByteValue(v.booleanValue() ? 1 : 0)),</span>
            BYTE,
            BOOLEAN));
  }

  private static DefaultFunctionResolver castToShort() {
<span class="fc" id="L101">    return FunctionDSL.define(</span>
<span class="fc" id="L102">        BuiltinFunctionName.CAST_TO_SHORT.getName(),</span>
<span class="fc" id="L103">        impl(</span>
<span class="fc" id="L104">            nullMissingHandling((v) -&gt; new ExprShortValue(Short.valueOf(v.stringValue()))),</span>
            SHORT,
            STRING),
<span class="fc" id="L107">        impl(nullMissingHandling((v) -&gt; new ExprShortValue(v.shortValue())), SHORT, DOUBLE),</span>
<span class="fc" id="L108">        impl(</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">            nullMissingHandling((v) -&gt; new ExprShortValue(v.booleanValue() ? 1 : 0)),</span>
            SHORT,
            BOOLEAN),
<span class="fc" id="L112">        impl(nullMissingHandling((v) -&gt; v), SHORT, UNDEFINED));</span>
  }

  private static DefaultFunctionResolver castToInt() {
<span class="fc" id="L116">    return FunctionDSL.define(</span>
<span class="fc" id="L117">        BuiltinFunctionName.CAST_TO_INT.getName(),</span>
<span class="fc" id="L118">        impl(</span>
<span class="fc" id="L119">            nullMissingHandling((v) -&gt; new ExprIntegerValue(Integer.valueOf(v.stringValue()))),</span>
            INTEGER,
            STRING),
<span class="fc" id="L122">        impl(nullMissingHandling((v) -&gt; new ExprIntegerValue(v.integerValue())), INTEGER, DOUBLE),</span>
<span class="fc" id="L123">        impl(</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">            nullMissingHandling((v) -&gt; new ExprIntegerValue(v.booleanValue() ? 1 : 0)),</span>
            INTEGER,
            BOOLEAN),
<span class="fc" id="L127">        impl(nullMissingHandling((v) -&gt; v), INTEGER, UNDEFINED));</span>
  }

  private static DefaultFunctionResolver castToLong() {
<span class="fc" id="L131">    return FunctionDSL.define(</span>
<span class="fc" id="L132">        BuiltinFunctionName.CAST_TO_LONG.getName(),</span>
<span class="fc" id="L133">        impl(</span>
<span class="fc" id="L134">            nullMissingHandling((v) -&gt; new ExprLongValue(Long.valueOf(v.stringValue()))),</span>
            LONG,
            STRING),
<span class="fc" id="L137">        impl(nullMissingHandling((v) -&gt; new ExprLongValue(v.longValue())), LONG, DOUBLE),</span>
<span class="fc" id="L138">        impl(</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">            nullMissingHandling((v) -&gt; new ExprLongValue(v.booleanValue() ? 1L : 0L)),</span>
            LONG,
            BOOLEAN),
<span class="fc" id="L142">        impl(nullMissingHandling((v) -&gt; v), LONG, UNDEFINED));</span>
  }

  private static DefaultFunctionResolver castToFloat() {
<span class="fc" id="L146">    return FunctionDSL.define(</span>
<span class="fc" id="L147">        BuiltinFunctionName.CAST_TO_FLOAT.getName(),</span>
<span class="fc" id="L148">        impl(</span>
<span class="fc" id="L149">            nullMissingHandling((v) -&gt; new ExprFloatValue(Float.valueOf(v.stringValue()))),</span>
            FLOAT,
            STRING),
<span class="fc" id="L152">        impl(nullMissingHandling((v) -&gt; new ExprFloatValue(v.floatValue())), FLOAT, DOUBLE),</span>
<span class="fc" id="L153">        impl(</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">            nullMissingHandling((v) -&gt; new ExprFloatValue(v.booleanValue() ? 1f : 0f)),</span>
            FLOAT,
            BOOLEAN),
<span class="fc" id="L157">        impl(nullMissingHandling((v) -&gt; v), FLOAT, UNDEFINED));</span>
  }

  private static DefaultFunctionResolver castToDouble() {
<span class="fc" id="L161">    return FunctionDSL.define(</span>
<span class="fc" id="L162">        BuiltinFunctionName.CAST_TO_DOUBLE.getName(),</span>
<span class="fc" id="L163">        impl(</span>
<span class="fc" id="L164">            nullMissingHandling((v) -&gt; new ExprDoubleValue(Double.valueOf(v.stringValue()))),</span>
            DOUBLE,
            STRING),
<span class="fc" id="L167">        impl(nullMissingHandling((v) -&gt; new ExprDoubleValue(v.doubleValue())), DOUBLE, DOUBLE),</span>
<span class="fc" id="L168">        impl(</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">            nullMissingHandling((v) -&gt; new ExprDoubleValue(v.booleanValue() ? 1D : 0D)),</span>
            DOUBLE,
            BOOLEAN),
<span class="fc" id="L172">        impl(nullMissingHandling((v) -&gt; v), DOUBLE, UNDEFINED));</span>
  }

  private static DefaultFunctionResolver castToBoolean() {
<span class="fc" id="L176">    return FunctionDSL.define(</span>
<span class="fc" id="L177">        BuiltinFunctionName.CAST_TO_BOOLEAN.getName(),</span>
<span class="fc" id="L178">        impl(</span>
<span class="fc" id="L179">            nullMissingHandling((v) -&gt; ExprBooleanValue.of(Boolean.valueOf(v.stringValue()))),</span>
            BOOLEAN,
            STRING),
<span class="fc" id="L182">        impl(</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">            nullMissingHandling((v) -&gt; ExprBooleanValue.of(v.doubleValue() != 0)), BOOLEAN, DOUBLE),</span>
<span class="fc" id="L184">        impl(nullMissingHandling((v) -&gt; v), BOOLEAN, BOOLEAN),</span>
<span class="fc" id="L185">        impl(nullMissingHandling((v) -&gt; v), BOOLEAN, UNDEFINED));</span>
  }

  private static DefaultFunctionResolver castToIp() {
<span class="fc" id="L189">    return FunctionDSL.define(</span>
<span class="fc" id="L190">        BuiltinFunctionName.CAST_TO_IP.getName(),</span>
<span class="fc" id="L191">        impl(nullMissingHandling((v) -&gt; new ExprIpValue(v.stringValue())), IP, STRING),</span>
<span class="fc" id="L192">        impl(nullMissingHandling((v) -&gt; v), IP, IP));</span>
  }

  private static DefaultFunctionResolver castToJson() {
<span class="fc" id="L196">    return FunctionDSL.define(</span>
<span class="fc" id="L197">        BuiltinFunctionName.CAST_TO_JSON.getName(),</span>
<span class="fc" id="L198">        impl(nullMissingHandling(JsonUtils::castJson), UNDEFINED, STRING));</span>
  }

  private static DefaultFunctionResolver castToDate() {
<span class="fc" id="L202">    return FunctionDSL.define(</span>
<span class="fc" id="L203">        BuiltinFunctionName.CAST_TO_DATE.getName(),</span>
<span class="fc" id="L204">        impl(nullMissingHandling((v) -&gt; new ExprDateValue(v.stringValue())), DATE, STRING),</span>
<span class="fc" id="L205">        impl(nullMissingHandling((v) -&gt; new ExprDateValue(v.dateValue())), DATE, TIMESTAMP),</span>
<span class="fc" id="L206">        impl(nullMissingHandling((v) -&gt; v), DATE, DATE));</span>
  }

  private static DefaultFunctionResolver castToTime() {
<span class="fc" id="L210">    return FunctionDSL.define(</span>
<span class="fc" id="L211">        BuiltinFunctionName.CAST_TO_TIME.getName(),</span>
<span class="fc" id="L212">        impl(nullMissingHandling((v) -&gt; new ExprTimeValue(v.stringValue())), TIME, STRING),</span>
<span class="fc" id="L213">        impl(nullMissingHandling((v) -&gt; new ExprTimeValue(v.timeValue())), TIME, TIMESTAMP),</span>
<span class="fc" id="L214">        impl(nullMissingHandling((v) -&gt; v), TIME, TIME));</span>
  }

  // `DATE`/`TIME` -&gt; `TIMESTAMP` cast tested in BinaryPredicateOperatorTest
  private static DefaultFunctionResolver castToTimestamp() {
<span class="fc" id="L219">    return FunctionDSL.define(</span>
<span class="fc" id="L220">        BuiltinFunctionName.CAST_TO_TIMESTAMP.getName(),</span>
<span class="fc" id="L221">        impl(</span>
<span class="fc" id="L222">            nullMissingHandling((v) -&gt; new ExprTimestampValue(v.stringValue())), TIMESTAMP, STRING),</span>
<span class="fc" id="L223">        impl(</span>
<span class="fc" id="L224">            nullMissingHandling((v) -&gt; new ExprTimestampValue(v.timestampValue())),</span>
            TIMESTAMP,
            DATE),
<span class="fc" id="L227">        implWithProperties(</span>
<span class="fc" id="L228">            nullMissingHandlingWithProperties(</span>
<span class="fc" id="L229">                (fp, v) -&gt; new ExprTimestampValue(((ExprTimeValue) v).timestampValue(fp))),</span>
            TIMESTAMP,
            TIME),
<span class="fc" id="L232">        impl(nullMissingHandling((v) -&gt; v), TIMESTAMP, TIMESTAMP));</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>