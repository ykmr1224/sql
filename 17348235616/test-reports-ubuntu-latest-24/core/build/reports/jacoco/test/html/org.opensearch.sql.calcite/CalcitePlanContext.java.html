<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CalcitePlanContext.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">core</a> &gt; <a href="index.source.html" class="el_package">org.opensearch.sql.calcite</a> &gt; <span class="el_source">CalcitePlanContext.java</span></div><h1>CalcitePlanContext.java</h1><pre class="source lang-java linenums">/*
 * Copyright OpenSearch Contributors
 * SPDX-License-Identifier: Apache-2.0
 */

package org.opensearch.sql.calcite;

import static org.opensearch.sql.calcite.utils.OpenSearchTypeFactory.TYPE_FACTORY;

import java.sql.Connection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Stack;
import java.util.function.BiFunction;
import lombok.Getter;
import lombok.Setter;
import org.apache.calcite.rex.RexCorrelVariable;
import org.apache.calcite.rex.RexLambdaRef;
import org.apache.calcite.rex.RexNode;
import org.apache.calcite.tools.FrameworkConfig;
import org.apache.calcite.tools.RelBuilder;
import org.opensearch.sql.ast.expression.UnresolvedExpression;
import org.opensearch.sql.calcite.utils.CalciteToolsHelper;
import org.opensearch.sql.executor.QueryType;
import org.opensearch.sql.expression.function.FunctionProperties;

public class CalcitePlanContext {

  public FrameworkConfig config;
  public final Connection connection;
  public final RelBuilder relBuilder;
  public final ExtendedRexBuilder rexBuilder;
  public final FunctionProperties functionProperties;
  public final QueryType queryType;
  public final Integer querySizeLimit;

  /** This thread local variable is only used to skip script encoding in script pushdown. */
<span class="pc" id="L40">  public static final ThreadLocal&lt;Boolean&gt; skipEncoding = ThreadLocal.withInitial(() -&gt; false);</span>

<span class="fc" id="L42">  @Getter @Setter private boolean isResolvingJoinCondition = false;</span>
<span class="fc" id="L43">  @Getter @Setter private boolean isResolvingSubquery = false;</span>
<span class="fc" id="L44">  @Getter @Setter private boolean inCoalesceFunction = false;</span>

  /**
   * The flag used to determine whether we do metadata field projection for user 1. If a project is
   * never visited, we will do metadata field projection for user 2. Else not because user may
   * intend to show the metadata field themselves. // TODO: use stack here if we want to do similar
   * projection for subquery.
   */
<span class="fc" id="L52">  @Getter @Setter private boolean isProjectVisited = false;</span>

<span class="fc" id="L54">  private final Stack&lt;RexCorrelVariable&gt; correlVar = new Stack&lt;&gt;();</span>
<span class="fc" id="L55">  private final Stack&lt;List&lt;RexNode&gt;&gt; windowPartitions = new Stack&lt;&gt;();</span>

  @Getter public Map&lt;String, RexLambdaRef&gt; rexLambdaRefMap;

<span class="fc" id="L59">  private CalcitePlanContext(FrameworkConfig config, Integer querySizeLimit, QueryType queryType) {</span>
<span class="fc" id="L60">    this.config = config;</span>
<span class="fc" id="L61">    this.querySizeLimit = querySizeLimit;</span>
<span class="fc" id="L62">    this.queryType = queryType;</span>
<span class="fc" id="L63">    this.connection = CalciteToolsHelper.connect(config, TYPE_FACTORY);</span>
<span class="fc" id="L64">    this.relBuilder = CalciteToolsHelper.create(config, TYPE_FACTORY, connection);</span>
<span class="fc" id="L65">    this.rexBuilder = new ExtendedRexBuilder(relBuilder.getRexBuilder());</span>
<span class="fc" id="L66">    this.functionProperties = new FunctionProperties(QueryType.PPL);</span>
<span class="fc" id="L67">    this.rexLambdaRefMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L68">  }</span>

  public RexNode resolveJoinCondition(
      UnresolvedExpression expr,
      BiFunction&lt;UnresolvedExpression, CalcitePlanContext, RexNode&gt; transformFunction) {
<span class="nc" id="L73">    isResolvingJoinCondition = true;</span>
<span class="nc" id="L74">    RexNode result = transformFunction.apply(expr, this);</span>
<span class="nc" id="L75">    isResolvingJoinCondition = false;</span>
<span class="nc" id="L76">    return result;</span>
  }

  public Optional&lt;RexCorrelVariable&gt; popCorrelVar() {
<span class="nc bnc" id="L80" title="All 2 branches missed.">    if (!correlVar.empty()) {</span>
<span class="nc" id="L81">      return Optional.of(correlVar.pop());</span>
    } else {
<span class="nc" id="L83">      return Optional.empty();</span>
    }
  }

  public void pushCorrelVar(RexCorrelVariable v) {
<span class="nc" id="L88">    correlVar.push(v);</span>
<span class="nc" id="L89">  }</span>

  public Optional&lt;RexCorrelVariable&gt; peekCorrelVar() {
<span class="nc bnc" id="L92" title="All 2 branches missed.">    if (!correlVar.empty()) {</span>
<span class="nc" id="L93">      return Optional.of(correlVar.peek());</span>
    } else {
<span class="nc" id="L95">      return Optional.empty();</span>
    }
  }

  public CalcitePlanContext clone() {
<span class="fc" id="L100">    return new CalcitePlanContext(config, querySizeLimit, queryType);</span>
  }

  public static CalcitePlanContext create(
      FrameworkConfig config, Integer querySizeLimit, QueryType queryType) {
<span class="fc" id="L105">    return new CalcitePlanContext(config, querySizeLimit, queryType);</span>
  }

  public void putRexLambdaRefMap(Map&lt;String, RexLambdaRef&gt; candidateMap) {
<span class="fc" id="L109">    this.rexLambdaRefMap.putAll(candidateMap);</span>
<span class="fc" id="L110">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>