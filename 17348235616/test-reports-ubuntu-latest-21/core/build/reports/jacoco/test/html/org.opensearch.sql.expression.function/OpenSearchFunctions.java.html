<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OpenSearchFunctions.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">core</a> &gt; <a href="index.source.html" class="el_package">org.opensearch.sql.expression.function</a> &gt; <span class="el_source">OpenSearchFunctions.java</span></div><h1>OpenSearchFunctions.java</h1><pre class="source lang-java linenums">/*
 * Copyright OpenSearch Contributors
 * SPDX-License-Identifier: Apache-2.0
 */

package org.opensearch.sql.expression.function;

import static org.opensearch.sql.data.type.ExprCoreType.BOOLEAN;

import java.util.List;
import java.util.stream.Collectors;
import lombok.Getter;
import lombok.Setter;
import lombok.experimental.UtilityClass;
import org.apache.commons.lang3.tuple.Pair;
import org.opensearch.sql.data.model.ExprValue;
import org.opensearch.sql.data.type.ExprType;
import org.opensearch.sql.expression.Expression;
import org.opensearch.sql.expression.FunctionExpression;
import org.opensearch.sql.expression.NamedArgumentExpression;
import org.opensearch.sql.expression.env.Environment;

@UtilityClass
public class OpenSearchFunctions {
  /** Add functions specific to OpenSearch to repository. */
  public void register(BuiltinFunctionRepository repository) {
<span class="fc" id="L27">    repository.register(match_bool_prefix());</span>
<span class="fc" id="L28">    repository.register(multi_match(BuiltinFunctionName.MULTI_MATCH));</span>
<span class="fc" id="L29">    repository.register(multi_match(BuiltinFunctionName.MULTIMATCH));</span>
<span class="fc" id="L30">    repository.register(multi_match(BuiltinFunctionName.MULTIMATCHQUERY));</span>
<span class="fc" id="L31">    repository.register(match(BuiltinFunctionName.MATCH));</span>
<span class="fc" id="L32">    repository.register(match(BuiltinFunctionName.MATCHQUERY));</span>
<span class="fc" id="L33">    repository.register(match(BuiltinFunctionName.MATCH_QUERY));</span>
<span class="fc" id="L34">    repository.register(simple_query_string());</span>
<span class="fc" id="L35">    repository.register(query());</span>
<span class="fc" id="L36">    repository.register(query_string());</span>

    // Register MATCHPHRASE as MATCH_PHRASE as well for backwards
    // compatibility.
<span class="fc" id="L40">    repository.register(match_phrase(BuiltinFunctionName.MATCH_PHRASE));</span>
<span class="fc" id="L41">    repository.register(match_phrase(BuiltinFunctionName.MATCHPHRASE));</span>
<span class="fc" id="L42">    repository.register(match_phrase(BuiltinFunctionName.MATCHPHRASEQUERY));</span>
<span class="fc" id="L43">    repository.register(match_phrase_prefix());</span>
<span class="fc" id="L44">    repository.register(wildcard_query(BuiltinFunctionName.WILDCARD_QUERY));</span>
<span class="fc" id="L45">    repository.register(wildcard_query(BuiltinFunctionName.WILDCARDQUERY));</span>
<span class="fc" id="L46">    repository.register(score(BuiltinFunctionName.SCORE));</span>
<span class="fc" id="L47">    repository.register(score(BuiltinFunctionName.SCOREQUERY));</span>
<span class="fc" id="L48">    repository.register(score(BuiltinFunctionName.SCORE_QUERY));</span>
    // Functions supported in SELECT clause
<span class="fc" id="L50">    repository.register(nested());</span>
<span class="fc" id="L51">  }</span>

  private static FunctionResolver match_bool_prefix() {
<span class="fc" id="L54">    FunctionName name = BuiltinFunctionName.MATCH_BOOL_PREFIX.getName();</span>
<span class="fc" id="L55">    return new RelevanceFunctionResolver(name);</span>
  }

  private static FunctionResolver match(BuiltinFunctionName match) {
<span class="fc" id="L59">    FunctionName funcName = match.getName();</span>
<span class="fc" id="L60">    return new RelevanceFunctionResolver(funcName);</span>
  }

  private static FunctionResolver match_phrase_prefix() {
<span class="fc" id="L64">    FunctionName funcName = BuiltinFunctionName.MATCH_PHRASE_PREFIX.getName();</span>
<span class="fc" id="L65">    return new RelevanceFunctionResolver(funcName);</span>
  }

  private static FunctionResolver match_phrase(BuiltinFunctionName matchPhrase) {
<span class="fc" id="L69">    FunctionName funcName = matchPhrase.getName();</span>
<span class="fc" id="L70">    return new RelevanceFunctionResolver(funcName);</span>
  }

  private static FunctionResolver multi_match(BuiltinFunctionName multiMatchName) {
<span class="fc" id="L74">    return new RelevanceFunctionResolver(multiMatchName.getName());</span>
  }

  private static FunctionResolver simple_query_string() {
<span class="fc" id="L78">    FunctionName funcName = BuiltinFunctionName.SIMPLE_QUERY_STRING.getName();</span>
<span class="fc" id="L79">    return new RelevanceFunctionResolver(funcName);</span>
  }

  private static FunctionResolver query() {
<span class="fc" id="L83">    FunctionName funcName = BuiltinFunctionName.QUERY.getName();</span>
<span class="fc" id="L84">    return new RelevanceFunctionResolver(funcName);</span>
  }

  private static FunctionResolver query_string() {
<span class="fc" id="L88">    FunctionName funcName = BuiltinFunctionName.QUERY_STRING.getName();</span>
<span class="fc" id="L89">    return new RelevanceFunctionResolver(funcName);</span>
  }

  private static FunctionResolver wildcard_query(BuiltinFunctionName wildcardQuery) {
<span class="fc" id="L93">    FunctionName funcName = wildcardQuery.getName();</span>
<span class="fc" id="L94">    return new RelevanceFunctionResolver(funcName);</span>
  }

  private static FunctionResolver nested() {
<span class="fc" id="L98">    return new FunctionResolver() {</span>
      @Override
      public Pair&lt;FunctionSignature, FunctionBuilder&gt; resolve(
          FunctionSignature unresolvedSignature) {
<span class="fc" id="L102">        return Pair.of(</span>
            unresolvedSignature,
            (functionProperties, arguments) -&gt;
<span class="fc" id="L105">                new FunctionExpression(BuiltinFunctionName.NESTED.getName(), arguments) {</span>
                  @Override
                  public ExprValue valueOf(Environment&lt;Expression, ExprValue&gt; valueEnv) {
<span class="fc" id="L108">                    return valueEnv.resolve(getArguments().get(0));</span>
                  }

                  @Override
                  public ExprType type() {
<span class="fc" id="L113">                    return getArguments().get(0).type();</span>
                  }
                });
      }

      @Override
      public FunctionName getFunctionName() {
<span class="fc" id="L120">        return BuiltinFunctionName.NESTED.getName();</span>
      }
    };
  }

  private static FunctionResolver score(BuiltinFunctionName score) {
<span class="fc" id="L126">    FunctionName funcName = score.getName();</span>
<span class="fc" id="L127">    return new RelevanceFunctionResolver(funcName);</span>
  }

  public static class OpenSearchFunction extends FunctionExpression {
    private final FunctionName functionName;
    private final List&lt;Expression&gt; arguments;

    @Getter @Setter private boolean isScoreTracked;

    /**
     * Required argument constructor.
     *
     * @param functionName name of the function
     * @param arguments a list of expressions
     */
    public OpenSearchFunction(FunctionName functionName, List&lt;Expression&gt; arguments) {
<span class="fc" id="L143">      super(functionName, arguments);</span>
<span class="fc" id="L144">      this.functionName = functionName;</span>
<span class="fc" id="L145">      this.arguments = arguments;</span>
<span class="fc" id="L146">      this.isScoreTracked = false;</span>
<span class="fc" id="L147">    }</span>

    @Override
    public ExprValue valueOf(Environment&lt;Expression, ExprValue&gt; valueEnv) {
<span class="fc" id="L151">      throw new UnsupportedOperationException(</span>
<span class="fc" id="L152">          String.format(</span>
              &quot;OpenSearch defined function [%s] is only supported in WHERE and HAVING clause.&quot;,
              functionName));
    }

    @Override
    public ExprType type() {
<span class="fc" id="L159">      return BOOLEAN;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L164">      List&lt;String&gt; args =</span>
<span class="fc" id="L165">          arguments.stream()</span>
<span class="fc" id="L166">              .map(</span>
                  arg -&gt;
<span class="fc" id="L168">                      String.format(</span>
                          &quot;%s=%s&quot;,
<span class="fc" id="L170">                          ((NamedArgumentExpression) arg).getArgName(),</span>
<span class="fc" id="L171">                          ((NamedArgumentExpression) arg).getValue().toString()))</span>
<span class="fc" id="L172">              .collect(Collectors.toList());</span>
<span class="fc" id="L173">      return String.format(&quot;%s(%s)&quot;, functionName, String.join(&quot;, &quot;, args));</span>
    }
  }

  /**
   * Static class to identify functional Expression which specifically designed for OpenSearch
   * storage runtime
   */
  public static class OpenSearchExecutableFunction extends FunctionExpression {
    private final FunctionName functionName;
    private final List&lt;Expression&gt; arguments;
    private final ExprType returnType;

    public OpenSearchExecutableFunction(
        FunctionName functionName, List&lt;Expression&gt; arguments, ExprType returnType) {
<span class="fc" id="L188">      super(functionName, arguments);</span>
<span class="fc" id="L189">      this.functionName = functionName;</span>
<span class="fc" id="L190">      this.arguments = arguments;</span>
<span class="fc" id="L191">      this.returnType = returnType;</span>
<span class="fc" id="L192">    }</span>

    @Override
    public ExprValue valueOf(Environment&lt;Expression, ExprValue&gt; valueEnv) {
<span class="fc" id="L196">      throw new UnsupportedOperationException(</span>
<span class="fc" id="L197">          String.format(</span>
              &quot;OpenSearch defined function [%s] is only supported in Eval operation.&quot;,
              functionName));
    }

    @Override
    public ExprType type() {
<span class="fc" id="L204">      return returnType;</span>
    }

    /**
     * Util method to generate probe implementation with given list of argument types, with marker
     * class `OpenSearchFunction` to annotate this is an OpenSearch specific expression.
     *
     * @param returnType return type.
     * @return Binary Function Implementation.
     */
    public static SerializableFunction&lt;FunctionName, Pair&lt;FunctionSignature, FunctionBuilder&gt;&gt;
        openSearchImpl(ExprType returnType, List&lt;ExprType&gt; args) {
<span class="fc" id="L216">      return functionName -&gt; {</span>
<span class="fc" id="L217">        FunctionSignature functionSignature = new FunctionSignature(functionName, args);</span>
<span class="fc" id="L218">        FunctionBuilder functionBuilder =</span>
            (functionProperties, arguments) -&gt;
<span class="fc" id="L220">                new OpenSearchFunctions.OpenSearchExecutableFunction(</span>
                    functionName, arguments, returnType);
<span class="fc" id="L222">        return Pair.of(functionSignature, functionBuilder);</span>
      };
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>